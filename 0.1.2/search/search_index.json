{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to ZodiacCore-Py","text":"<p>The opinionated, async-first core library for modern Python web services.</p> <ul> <li>Source: GitHub \u2014 TTWShell/ZodiacCore-Py</li> <li>Package: PyPI \u2014 zodiac-core</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Installation \u2014 Install and optional extras (SQL, Mongo).</li> <li>Getting started \u2014 Basic usage and examples.</li> <li>API Reference \u2014 Configuration, context, database, exceptions, logging, middleware, pagination, routing, schemas.</li> </ul>"},{"location":"#project-links","title":"Project links","text":"<ul> <li>Contributing \u2014 How to contribute.</li> <li>License \u2014 MIT License.</li> </ul>"},{"location":"api/config/","title":"Configuration Management","text":"<p>ZodiacCore provides a robust utility for managing application settings using <code>.ini</code> files. It is designed to follow the \"Base + Override\" pattern, making it ideal for multi-environment deployments (Development, Testing, Production).</p>"},{"location":"api/config/#1-core-concepts","title":"1. Core Concepts","text":""},{"location":"api/config/#environment-based-loading","title":"Environment-Based Loading","text":"<p>The configuration system automatically detects your current environment (via environment variables) and loads files in a specific order:</p> <ol> <li>Base Config: Files like <code>app.ini</code>. These are loaded first.</li> <li>Environment Config: Files like <code>app.production.ini</code>. These are loaded second, overriding any matching keys from the base config.</li> </ol>"},{"location":"api/config/#dot-notation-access","title":"Dot-Notation Access","text":"<p>Instead of using dictionary keys (e.g., <code>config['db']['host']</code>), ZodiacCore can convert your settings into a <code>SimpleNamespace</code>, allowing for cleaner dot-notation access (e.g., <code>config.db.host</code>).</p>"},{"location":"api/config/#2-setting-up-your-config-folder","title":"2. Setting Up Your Config Folder","text":"<p>A typical production-ready configuration folder structure:</p> <pre><code>config/\n\u251c\u2500\u2500 app.ini             # Default settings (all environments)\n\u251c\u2500\u2500 app.develop.ini     # Local development overrides\n\u2514\u2500\u2500 app.production.ini  # Production secrets/tuning\n</code></pre>"},{"location":"api/config/#loading-the-config","title":"Loading the Config","text":"<p>You can use <code>ConfigManagement</code> to find the correct files and then load them using your preferred library (like <code>configparser</code> or <code>dependency-injector</code>).</p> <pre><code>from pathlib import Path\nfrom zodiac_core import ConfigManagement\n\n# 1. Get the list of files in correct loading order\nconfig_dir = Path(__file__).parent / \"config\"\nconfig_files = ConfigManagement.get_config_files(\n    search_paths=[config_dir],\n    env_var=\"APPLICATION_ENVIRONMENT\",  # Default: APPLICATION_ENVIRONMENT\n    default_env=\"develop\"                # Fallback if env_var is missing\n)\n\n# Returns: ['.../config/app.ini', '.../config/app.develop.ini']\n</code></pre>"},{"location":"api/config/#3-configuration-objects","title":"3. Configuration Objects","text":"<p>ZodiacCore provides two ways to access your configuration data using <code>ConfigManagement.provide_config</code>:</p>"},{"location":"api/config/#mode-a-simplenamespace-quick-access","title":"Mode A: SimpleNamespace (Quick Access)","text":"<p>This mode is useful for rapid prototyping. It converts the dictionary into a <code>SimpleNamespace</code>, allowing for dot-notation access but without type hints or validation.</p> <pre><code>raw_data = {\"db\": {\"host\": \"localhost\", \"port\": 5432}}\nconfig = ConfigManagement.provide_config(raw_data)\n\nprint(config.db.host)  # 'localhost'\n</code></pre>"},{"location":"api/config/#mode-b-pydantic-model-recommended","title":"Mode B: Pydantic Model (Recommended)","text":"<p>For production applications, it is highly recommended to use a Pydantic model. This provides: 1. Type Safety: Full IDE autocompletion and type checking. 2. Validation: Runtime checks to ensure your configuration is valid. 3. Defaults: Automatically fill in missing values defined in your schema.</p> <pre><code>from pydantic import BaseModel\nfrom zodiac_core import ConfigManagement\n\nclass DbConfig(BaseModel):\n    host: str\n    port: int = 5432\n\nclass AppConfig(BaseModel):\n    db: DbConfig\n\nraw_data = {\"db\": {\"host\": \"localhost\"}}\n# Pass the model class as the second argument\nconfig = ConfigManagement.provide_config(raw_data, AppConfig)\n\nprint(config.db.host)  # 'localhost' (with IDE autocomplete!)\nprint(config.db.port)  # 5432 (default value applied)\n</code></pre>"},{"location":"api/config/#4-api-reference","title":"4. API Reference","text":""},{"location":"api/config/#environment-enum","title":"Environment Enum","text":""},{"location":"api/config/#zodiac_core.config.Environment","title":"<code>zodiac_core.config.Environment</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported application environments.</p> Source code in <code>zodiac_core/config.py</code> <pre><code>class Environment(str, Enum):\n    \"\"\"\n    Supported application environments.\n    \"\"\"\n\n    DEVELOP = \"develop\"  # Local development\n    TESTING = \"testing\"  # Testing environment\n    STAGING = \"staging\"  # Staging environment (reserved)\n    PRODUCTION = \"production\"  # Production environment\n</code></pre>"},{"location":"api/config/#configuration-management_1","title":"Configuration Management","text":""},{"location":"api/config/#zodiac_core.config.ConfigManagement","title":"<code>zodiac_core.config.ConfigManagement</code>","text":"<p>Configuration management utility for scanning, loading, and converting configuration files.</p> <p>This utility is designed to work well with configuration loading patterns where subsequent files override previous ones (e.g., standard <code>configparser</code> or <code>dependency-injector</code>).</p> <p>See: https://python-dependency-injector.ets-labs.org/providers/configuration.html</p> Source code in <code>zodiac_core/config.py</code> <pre><code>class ConfigManagement:\n    \"\"\"\n    Configuration management utility for scanning, loading, and converting configuration files.\n\n    This utility is designed to work well with configuration loading patterns where\n    subsequent files override previous ones (e.g., standard `configparser` or\n    `dependency-injector`).\n\n    See: https://python-dependency-injector.ets-labs.org/providers/configuration.html\n    \"\"\"\n\n    @staticmethod\n    def get_config_files(\n        search_paths: List[Union[str, Path]],\n        env_var: str = \"APPLICATION_ENVIRONMENT\",\n        default_env: str = \"production\",\n    ) -&gt; List[str]:\n        \"\"\"\n        Scans specified directories for configuration files and returns them in loading order.\n\n        The scanning strategy follows these rules:\n        1. Base Config: Files with at most one dot (e.g., 'app.ini'). Loaded first.\n        2. Env Config: Files matching '{name}.{env}.ini' (e.g., 'app.develop.ini'). Loaded second.\n\n        The returned order (Base -&gt; Env) ensures that environment-specific settings\n        override base settings when loaded by configuration providers.\n\n        Files not matching the current environment but belonging to a known Environment enum\n        are silently skipped. Files with unknown environment suffixes are logged as debug.\n\n        Args:\n            search_paths: List of directory paths to search. **REQUIRED**.\n            env_var: Environment variable name to determine current environment.\n            default_env: Fallback environment if env_var is not set.\n\n        Returns:\n            A list of absolute paths to configuration files, sorted by priority (Base -&gt; Env).\n\n        Example:\n            ```python\n            from pathlib import Path\n            from zodiac_core import ConfigManagement\n\n            # Resolve config path relative to your main application file\n            config_dir = Path(__file__).parent / \"config\"\n            files = ConfigManagement.get_config_files(search_paths=[config_dir])\n            ```\n        \"\"\"\n\n        target_env = os.environ.get(env_var, default_env).lower()\n        base_files = []\n        env_files = []\n\n        # Normalize paths\n        abs_paths = [Path(p).resolve() for p in search_paths if p]\n\n        # Valid environments set for quick lookup\n        valid_envs = {e.value for e in Environment}\n\n        for config_dir in abs_paths:\n            if not config_dir.exists():\n                continue\n\n            # Get all .ini files and sort them to ensure deterministic order\n            ini_files = sorted(glob.glob(str(config_dir / \"*.ini\")))\n\n            for file_path in ini_files:\n                filename = os.path.basename(file_path)\n\n                if ConfigManagement.__is_base_config_file(filename):\n                    base_files.append(str(file_path))\n                    continue\n\n                # Rule 2: Env Config ({name}.{env}.ini)\n                candidate_env = ConfigManagement.__get_configuration_env(filename)\n\n                if candidate_env == target_env:\n                    env_files.append(str(file_path))\n                elif candidate_env in valid_envs:\n                    # Valid environment file, but not for current environment. Skip silently.\n                    pass\n                else:\n                    # Unknown environment or weird format. Log it.\n                    logger.debug(f\"Ignored config file (unknown env/format): {file_path}\")\n\n        return base_files + env_files\n\n    @overload\n    @staticmethod\n    def provide_config(config: dict) -&gt; SimpleNamespace: ...\n\n    @overload\n    @staticmethod\n    def provide_config(config: dict, model: Type[T]) -&gt; T: ...\n\n    @staticmethod\n    def provide_config(config: dict = None, model: Type[T] = None) -&gt; Union[SimpleNamespace, T]:\n        \"\"\"\n        Converts a configuration dictionary into a structured object.\n\n        Supports two modes:\n        1. **SimpleNamespace mode** (default): Returns a SimpleNamespace for dot notation access.\n        2. **Pydantic model mode**: Pass a Pydantic model class to get type-safe, validated config.\n\n        Args:\n            config: The configuration dictionary to convert.\n            model: Optional Pydantic model class. If provided, returns an instance of this model.\n\n        Returns:\n            SimpleNamespace if no model provided, otherwise an instance of the model.\n\n        Example:\n            ```python\n            # Mode 1: SimpleNamespace (no type hints, but convenient)\n            config = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}})\n            print(config.db.host)  # \"localhost\"\n\n            # Mode 2: Pydantic model (full type hints and validation)\n            from pydantic import BaseModel\n\n            class DbConfig(BaseModel):\n                host: str\n                port: int = 5432\n\n            class AppConfig(BaseModel):\n                db: DbConfig\n\n            config = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}}, AppConfig)\n            print(config.db.host)  # IDE autocomplete works!\n            print(config.db.port)  # 5432 (default value)\n            ```\n        \"\"\"\n        if config is None:\n            config = {}\n\n        # Pydantic model mode: delegate to Pydantic for validation and type coercion\n        if model is not None:\n            return model(**config)\n\n        # SimpleNamespace mode: recursive conversion\n        def _convert(value):\n            if isinstance(value, dict):\n                return SimpleNamespace(**{k: _convert(v) for k, v in value.items()})\n            elif isinstance(value, list):\n                return [_convert(item) for item in value]\n            return value\n\n        return _convert(config)\n\n    @staticmethod\n    def __is_base_config_file(filename: str) -&gt; bool:\n        \"\"\"\n        Checks if a filename represents a base configuration file.\n\n        Base files are identified by having one dot in their name.\n        \"\"\"\n        return filename.count(\".\") == 1\n\n    @staticmethod\n    def __get_configuration_env(filename: str) -&gt; str:\n        \"\"\"\n        Extracts the environment name segment from a configuration filename.\n\n        Expected format: {name}.{env}.ini\n        \"\"\"\n        parts = filename.split(\".\")\n        # Caller ensure we have at least 2 dots (split into &gt;= 3 parts)\n        # by checking __is_base_config_file first.\n        return parts[-2].lower()\n</code></pre>"},{"location":"api/config/#zodiac_core.config.ConfigManagement.get_config_files","title":"<code>get_config_files(search_paths, env_var='APPLICATION_ENVIRONMENT', default_env='production')</code>  <code>staticmethod</code>","text":"<p>Scans specified directories for configuration files and returns them in loading order.</p> <p>The scanning strategy follows these rules: 1. Base Config: Files with at most one dot (e.g., 'app.ini'). Loaded first. 2. Env Config: Files matching '{name}.{env}.ini' (e.g., 'app.develop.ini'). Loaded second.</p> <p>The returned order (Base -&gt; Env) ensures that environment-specific settings override base settings when loaded by configuration providers.</p> <p>Files not matching the current environment but belonging to a known Environment enum are silently skipped. Files with unknown environment suffixes are logged as debug.</p> <p>Parameters:</p> Name Type Description Default <code>search_paths</code> <code>List[Union[str, Path]]</code> <p>List of directory paths to search. REQUIRED.</p> required <code>env_var</code> <code>str</code> <p>Environment variable name to determine current environment.</p> <code>'APPLICATION_ENVIRONMENT'</code> <code>default_env</code> <code>str</code> <p>Fallback environment if env_var is not set.</p> <code>'production'</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of absolute paths to configuration files, sorted by priority (Base -&gt; Env).</p> Example <pre><code>from pathlib import Path\nfrom zodiac_core import ConfigManagement\n\n# Resolve config path relative to your main application file\nconfig_dir = Path(__file__).parent / \"config\"\nfiles = ConfigManagement.get_config_files(search_paths=[config_dir])\n</code></pre> Source code in <code>zodiac_core/config.py</code> <pre><code>@staticmethod\ndef get_config_files(\n    search_paths: List[Union[str, Path]],\n    env_var: str = \"APPLICATION_ENVIRONMENT\",\n    default_env: str = \"production\",\n) -&gt; List[str]:\n    \"\"\"\n    Scans specified directories for configuration files and returns them in loading order.\n\n    The scanning strategy follows these rules:\n    1. Base Config: Files with at most one dot (e.g., 'app.ini'). Loaded first.\n    2. Env Config: Files matching '{name}.{env}.ini' (e.g., 'app.develop.ini'). Loaded second.\n\n    The returned order (Base -&gt; Env) ensures that environment-specific settings\n    override base settings when loaded by configuration providers.\n\n    Files not matching the current environment but belonging to a known Environment enum\n    are silently skipped. Files with unknown environment suffixes are logged as debug.\n\n    Args:\n        search_paths: List of directory paths to search. **REQUIRED**.\n        env_var: Environment variable name to determine current environment.\n        default_env: Fallback environment if env_var is not set.\n\n    Returns:\n        A list of absolute paths to configuration files, sorted by priority (Base -&gt; Env).\n\n    Example:\n        ```python\n        from pathlib import Path\n        from zodiac_core import ConfigManagement\n\n        # Resolve config path relative to your main application file\n        config_dir = Path(__file__).parent / \"config\"\n        files = ConfigManagement.get_config_files(search_paths=[config_dir])\n        ```\n    \"\"\"\n\n    target_env = os.environ.get(env_var, default_env).lower()\n    base_files = []\n    env_files = []\n\n    # Normalize paths\n    abs_paths = [Path(p).resolve() for p in search_paths if p]\n\n    # Valid environments set for quick lookup\n    valid_envs = {e.value for e in Environment}\n\n    for config_dir in abs_paths:\n        if not config_dir.exists():\n            continue\n\n        # Get all .ini files and sort them to ensure deterministic order\n        ini_files = sorted(glob.glob(str(config_dir / \"*.ini\")))\n\n        for file_path in ini_files:\n            filename = os.path.basename(file_path)\n\n            if ConfigManagement.__is_base_config_file(filename):\n                base_files.append(str(file_path))\n                continue\n\n            # Rule 2: Env Config ({name}.{env}.ini)\n            candidate_env = ConfigManagement.__get_configuration_env(filename)\n\n            if candidate_env == target_env:\n                env_files.append(str(file_path))\n            elif candidate_env in valid_envs:\n                # Valid environment file, but not for current environment. Skip silently.\n                pass\n            else:\n                # Unknown environment or weird format. Log it.\n                logger.debug(f\"Ignored config file (unknown env/format): {file_path}\")\n\n    return base_files + env_files\n</code></pre>"},{"location":"api/config/#zodiac_core.config.ConfigManagement.provide_config","title":"<code>provide_config(config=None, model=None)</code>  <code>staticmethod</code>","text":"<pre><code>provide_config(config: dict) -&gt; SimpleNamespace\n</code></pre><pre><code>provide_config(config: dict, model: Type[T]) -&gt; T\n</code></pre> <p>Converts a configuration dictionary into a structured object.</p> <p>Supports two modes: 1. SimpleNamespace mode (default): Returns a SimpleNamespace for dot notation access. 2. Pydantic model mode: Pass a Pydantic model class to get type-safe, validated config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration dictionary to convert.</p> <code>None</code> <code>model</code> <code>Type[T]</code> <p>Optional Pydantic model class. If provided, returns an instance of this model.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[SimpleNamespace, T]</code> <p>SimpleNamespace if no model provided, otherwise an instance of the model.</p> Example <pre><code># Mode 1: SimpleNamespace (no type hints, but convenient)\nconfig = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}})\nprint(config.db.host)  # \"localhost\"\n\n# Mode 2: Pydantic model (full type hints and validation)\nfrom pydantic import BaseModel\n\nclass DbConfig(BaseModel):\n    host: str\n    port: int = 5432\n\nclass AppConfig(BaseModel):\n    db: DbConfig\n\nconfig = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}}, AppConfig)\nprint(config.db.host)  # IDE autocomplete works!\nprint(config.db.port)  # 5432 (default value)\n</code></pre> Source code in <code>zodiac_core/config.py</code> <pre><code>@staticmethod\ndef provide_config(config: dict = None, model: Type[T] = None) -&gt; Union[SimpleNamespace, T]:\n    \"\"\"\n    Converts a configuration dictionary into a structured object.\n\n    Supports two modes:\n    1. **SimpleNamespace mode** (default): Returns a SimpleNamespace for dot notation access.\n    2. **Pydantic model mode**: Pass a Pydantic model class to get type-safe, validated config.\n\n    Args:\n        config: The configuration dictionary to convert.\n        model: Optional Pydantic model class. If provided, returns an instance of this model.\n\n    Returns:\n        SimpleNamespace if no model provided, otherwise an instance of the model.\n\n    Example:\n        ```python\n        # Mode 1: SimpleNamespace (no type hints, but convenient)\n        config = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}})\n        print(config.db.host)  # \"localhost\"\n\n        # Mode 2: Pydantic model (full type hints and validation)\n        from pydantic import BaseModel\n\n        class DbConfig(BaseModel):\n            host: str\n            port: int = 5432\n\n        class AppConfig(BaseModel):\n            db: DbConfig\n\n        config = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}}, AppConfig)\n        print(config.db.host)  # IDE autocomplete works!\n        print(config.db.port)  # 5432 (default value)\n        ```\n    \"\"\"\n    if config is None:\n        config = {}\n\n    # Pydantic model mode: delegate to Pydantic for validation and type coercion\n    if model is not None:\n        return model(**config)\n\n    # SimpleNamespace mode: recursive conversion\n    def _convert(value):\n        if isinstance(value, dict):\n            return SimpleNamespace(**{k: _convert(v) for k, v in value.items()})\n        elif isinstance(value, list):\n            return [_convert(item) for item in value]\n        return value\n\n    return _convert(config)\n</code></pre>"},{"location":"api/context/","title":"Tracing &amp; HTTP Clients","text":"<p>ZodiacCore provides built-in support for Distributed Tracing. It ensures that a single Request ID (Trace ID) flows through your entire ecosystem: from the incoming request, through your logs, and out to downstream microservices via HTTP clients.</p>"},{"location":"api/context/#1-how-it-works","title":"1. How it Works","text":"<ol> <li>Extraction: <code>TraceIDMiddleware</code> catches <code>X-Request-ID</code> from incoming headers (or generates a new one).</li> <li>Storage: The ID is stored in a thread-safe <code>ContextVar</code> (managed by <code>zodiac_core.context</code>).</li> <li>Observation: Logging utilities automatically pick up this ID from the context.</li> <li>Propagation: <code>ZodiacClient</code> automatically injects this ID into outgoing HTTP requests.</li> </ol>"},{"location":"api/context/#2-distributed-tracing-http-clients","title":"2. Distributed Tracing (HTTP Clients)","text":"<p>When calling other services, use <code>ZodiacClient</code> (Async) or <code>ZodiacSyncClient</code> (Sync). They are thin wrappers around <code>httpx</code> that automatically handle Trace ID propagation.</p>"},{"location":"api/context/#async-usage-recommended","title":"Async Usage (Recommended)","text":"<pre><code>from zodiac_core.http import ZodiacClient\n\nasync def call_downstream():\n    async with ZodiacClient(base_url=\"https://api.internal.service\") as client:\n        # X-Request-ID is automatically added to headers\n        response = await client.get(\"/data\")\n        return response.json()\n</code></pre>"},{"location":"api/context/#sync-usage","title":"Sync Usage","text":"<pre><code>from zodiac_core.http import ZodiacSyncClient\n\ndef sync_call():\n    with ZodiacSyncClient() as client:\n        resp = client.get(\"https://google.com\")\n        return resp.status_code\n</code></pre>"},{"location":"api/context/#3-manual-context-access","title":"3. Manual Context Access","text":"<p>In rare cases where you aren't using <code>ZodiacClient</code> (e.g., using <code>aiohttp</code> or <code>requests</code>), you can manually retrieve the current Request ID.</p> <pre><code>from zodiac_core.context import get_request_id\n\nrequest_id = get_request_id()\n# Manually pass it to other systems...\n</code></pre>"},{"location":"api/context/#4-api-reference","title":"4. API Reference","text":""},{"location":"api/context/#http-clients-tracing-enabled","title":"HTTP Clients (Tracing Enabled)","text":""},{"location":"api/context/#zodiac_core.http.ZodiacClient","title":"<code>ZodiacClient</code>","text":"<p>               Bases: <code>AsyncClient</code></p> <p>A wrapper around httpx.AsyncClient that automatically injects the current Trace ID into outgoing requests.</p> Source code in <code>zodiac_core/http.py</code> <pre><code>class ZodiacClient(httpx.AsyncClient):\n    \"\"\"\n    A wrapper around httpx.AsyncClient that automatically injects\n    the current Trace ID into outgoing requests.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        timeout: float = 30.0,\n        event_hooks: Optional[Dict[str, Any]] = None,\n        **kwargs: Any,\n    ):\n        super().__init__(\n            timeout=timeout,\n            event_hooks=_merge_hooks(event_hooks, _inject_trace_id_async_hook),\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/context/#zodiac_core.http.ZodiacSyncClient","title":"<code>ZodiacSyncClient</code>","text":"<p>               Bases: <code>Client</code></p> <p>A wrapper around httpx.Client that automatically injects the current Trace ID into outgoing requests.</p> Source code in <code>zodiac_core/http.py</code> <pre><code>class ZodiacSyncClient(httpx.Client):\n    \"\"\"\n    A wrapper around httpx.Client that automatically injects\n    the current Trace ID into outgoing requests.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        timeout: float = 30.0,\n        event_hooks: Optional[Dict[str, Any]] = None,\n        **kwargs: Any,\n    ):\n        super().__init__(\n            timeout=timeout,\n            event_hooks=_merge_hooks(event_hooks, _inject_trace_id_hook),\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/context/#context-utilities","title":"Context Utilities","text":""},{"location":"api/context/#zodiac_core.context.get_request_id","title":"<code>get_request_id()</code>","text":"<p>Retrieve the current Request ID from the context.</p> Usage <pre><code>headers = {\"X-Request-ID\": get_request_id()}\nrequests.get(url, headers=headers)\n</code></pre> Source code in <code>zodiac_core/context.py</code> <pre><code>def get_request_id() -&gt; Optional[str]:\n    \"\"\"\n    Retrieve the current Request ID from the context.\n\n    Usage:\n        ```python\n        headers = {\"X-Request-ID\": get_request_id()}\n        requests.get(url, headers=headers)\n        ```\n    \"\"\"\n    return _request_id_ctx_var.get()\n</code></pre>"},{"location":"api/db/","title":"Database Engine &amp; ORM","text":"<p>ZodiacCore provides a high-performance, async-first database abstraction layer built on top of SQLModel and SQLAlchemy 2.0. It simplifies session management, connection pooling, and standardizes model definitions.</p>"},{"location":"api/db/#1-core-concepts","title":"1. Core Concepts","text":""},{"location":"api/db/#the-database-manager","title":"The Database Manager","text":"<p>The <code>DatabaseManager</code> (exposed as the global <code>db</code> instance) is a strict singleton that manages the SQLAlchemy <code>AsyncEngine</code> and <code>async_sessionmaker</code>. It ensures that your application maintains a single connection pool, which is critical for performance and resource management.</p>"},{"location":"api/db/#the-repository-pattern","title":"The Repository Pattern","text":"<p>We encourage the use of the Repository Pattern via <code>BaseSQLRepository</code>. This decouples your business logic from database-specific code, making your application more maintainable and easier to unit test with mocks.</p>"},{"location":"api/db/#2-model-definitions","title":"2. Model Definitions","text":"<p>ZodiacCore provides several mixins and base classes in <code>zodiac_core.db.sql</code> to standardize your database schema.</p>"},{"location":"api/db/#standard-base-models","title":"Standard Base Models","text":"<p>Instead of inheriting from <code>SQLModel</code> directly, we recommend using our pre-configured base models:</p> Base Model Primary Key Timestamps <code>IntIDModel</code> <code>id: int</code> (Auto-increment) <code>created_at</code>, <code>updated_at</code> <code>UUIDModel</code> <code>id: UUID</code> (v4) <code>created_at</code>, <code>updated_at</code>"},{"location":"api/db/#example-using-base-models","title":"Example: Using Base Models","text":"<pre><code>from zodiac_core.db.sql import IntIDModel\nfrom sqlmodel import Field\n\nclass User(IntIDModel, table=True):\n    username: str = Field(unique=True, index=True)\n    email: str\n</code></pre>"},{"location":"api/db/#automatic-timestamps","title":"Automatic Timestamps","text":"<p>Both <code>IntIDModel</code> and <code>UUIDModel</code> include <code>SQLDateTimeMixin</code>, which provides:</p> <ul> <li>created_at: Automatically set on insertion.</li> <li>updated_at: Automatically updated on every save via a SQLAlchemy event listener.</li> </ul>"},{"location":"api/db/#3-configuration-lifecycle","title":"3. Configuration &amp; Lifecycle","text":"<p>You should initialize the database during your application's startup and ensure it shuts down cleanly.</p>"},{"location":"api/db/#fastapi-integration","title":"FastAPI Integration","text":"<p>We recommend using the lifespan context manager (FastAPI 0.93+). The legacy <code>on_event(\"startup\")</code> / <code>on_event(\"shutdown\")</code> are deprecated.</p> <pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom zodiac_core.db.session import db\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    db.setup(\n        \"postgresql+asyncpg://user:pass@localhost/dbname\",\n        pool_size=20,\n        max_overflow=10,\n        echo=False\n    )\n    await db.create_all()  # Optional: create tables if they don't exist\n    yield\n    await db.shutdown()\n\napp = FastAPI(lifespan=lifespan)\n</code></pre>"},{"location":"api/db/#4-working-with-repositories","title":"4. Working with Repositories","text":"<p>Inherit from <code>BaseSQLRepository</code> to create your data access layer.</p> <pre><code>from zodiac_core.db.repository import BaseSQLRepository\nfrom sqlalchemy import select\nfrom .models import User\n\nclass UserRepository(BaseSQLRepository):\n    async def find_by_username(self, username: str) -&gt; User | None:\n        async with self.session() as session:\n            stmt = select(User).where(User.username == username)\n            result = await session.execute(stmt)\n            return result.scalar_one_or_none()\n\n    async def create_user(self, user: User) -&gt; User:\n        async with self.session() as session:\n            session.add(user)\n            await session.commit()\n            await session.refresh(user)\n            return user\n</code></pre>"},{"location":"api/db/#5-multi-database-support","title":"5. Multi-Database Support","text":"<p>ZodiacCore supports multiple database connections simultaneously. This is essential for architectures involving:</p> <ul> <li>Read-Write Splitting: Routing writes to a Master and reads to a Replica.</li> <li>Vertical Partitioning: Storing different modules (e.g., Users, Analytics) in separate databases.</li> </ul>"},{"location":"api/db/#registering-named-databases","title":"Registering Named Databases","text":"<p>You can call <code>db.setup()</code> multiple times with different <code>name</code> arguments.</p> <pre><code># Primary Database (Master)\ndb.setup(\"postgresql+asyncpg://master_db_url\", name=\"default\")\n\n# Read-only Replica\ndb.setup(\"postgresql+asyncpg://replica_db_url\", name=\"read_only\")\n</code></pre>"},{"location":"api/db/#binding-repositories-to-a-database","title":"Binding Repositories to a Database","text":"<p>When creating a repository, specify which database it should use via <code>db_name</code>.</p> <pre><code>class ReadOnlyUserRepository(BaseSQLRepository):\n    def __init__(self):\n        # This repo will always use the 'read_only' engine\n        super().__init__(db_name=\"read_only\")\n\n    async def get_total_users(self) -&gt; int:\n        async with self.session() as session:\n            # Executes on replica\n            ...\n</code></pre>"},{"location":"api/db/#6-api-reference","title":"6. API Reference","text":""},{"location":"api/db/#session-lifecycle","title":"Session &amp; Lifecycle","text":""},{"location":"api/db/#zodiac_core.db.session","title":"<code>zodiac_core.db.session</code>","text":""},{"location":"api/db/#zodiac_core.db.session.DEFAULT_DB_NAME","title":"<code>DEFAULT_DB_NAME = 'default'</code>  <code>module-attribute</code>","text":""},{"location":"api/db/#zodiac_core.db.session.db","title":"<code>db = DatabaseManager()</code>  <code>module-attribute</code>","text":""},{"location":"api/db/#zodiac_core.db.session.DatabaseManager","title":"<code>DatabaseManager</code>","text":"<p>Manages multiple Async Database Engines and Session Factories. Implemented as a Strict Singleton to coordinate connection pools.</p> <p>Integration Examples:</p> <ol> <li> <p>Native FastAPI (Lifespan + Depends):</p> <pre><code># main.py\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom zodiac_core.db.session import db, get_session\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    db.setup(\"sqlite+aiosqlite:///database.db\")\n    yield\n    await db.shutdown()\n\napp = FastAPI(lifespan=lifespan)\n\n@app.get(\"/items\")\nasync def list_items(session: AsyncSession = Depends(get_session)):\n    return {\"status\": \"ok\"}\n</code></pre> </li> <li> <p>Dependency Injector (Using provided init_db_resource):</p> <pre><code># containers.py\nfrom dependency_injector import containers, providers\nfrom zodiac_core.db.session import init_db_resource\n\nclass Container(containers.DeclarativeContainer):\n    config = providers.Configuration()\n\n    # Use the pre-built resource helper\n    db_manager = providers.Resource(\n        init_db_resource,\n        database_url=config.db.url,\n        echo=config.db.echo.as_bool(),\n    )\n</code></pre> </li> </ol> Source code in <code>zodiac_core/db/session.py</code> <pre><code>class DatabaseManager:\n    \"\"\"\n    Manages multiple Async Database Engines and Session Factories.\n    Implemented as a Strict Singleton to coordinate connection pools.\n\n    Integration Examples:\n\n    1. **Native FastAPI (Lifespan + Depends):**\n\n        ```python\n        # main.py\n        from contextlib import asynccontextmanager\n        from fastapi import FastAPI, Depends\n        from sqlalchemy.ext.asyncio import AsyncSession\n        from zodiac_core.db.session import db, get_session\n\n        @asynccontextmanager\n        async def lifespan(app: FastAPI):\n            db.setup(\"sqlite+aiosqlite:///database.db\")\n            yield\n            await db.shutdown()\n\n        app = FastAPI(lifespan=lifespan)\n\n        @app.get(\"/items\")\n        async def list_items(session: AsyncSession = Depends(get_session)):\n            return {\"status\": \"ok\"}\n        ```\n\n    2. **Dependency Injector (Using provided init_db_resource):**\n\n        ```python\n        # containers.py\n        from dependency_injector import containers, providers\n        from zodiac_core.db.session import init_db_resource\n\n        class Container(containers.DeclarativeContainer):\n            config = providers.Configuration()\n\n            # Use the pre-built resource helper\n            db_manager = providers.Resource(\n                init_db_resource,\n                database_url=config.db.url,\n                echo=config.db.echo.as_bool(),\n            )\n        ```\n    \"\"\"\n\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._engines: Dict[str, AsyncEngine] = {}\n            cls._instance._session_factories: Dict[str, async_sessionmaker[AsyncSession]] = {}\n        return cls._instance\n\n    def get_engine(self, name: str = DEFAULT_DB_NAME) -&gt; AsyncEngine:\n        \"\"\"Access a specific SQLAlchemy AsyncEngine by name.\"\"\"\n        if name not in self._engines:\n            raise RuntimeError(f\"Database engine '{name}' is not initialized. Call db.setup(name='{name}') first.\")\n        return self._engines[name]\n\n    def get_factory(self, name: str = DEFAULT_DB_NAME) -&gt; async_sessionmaker[AsyncSession]:\n        \"\"\"Access a specific AsyncSession factory by name.\"\"\"\n        if name not in self._session_factories:\n            raise RuntimeError(f\"Session factory for '{name}' is not initialized. Call db.setup(name='{name}') first.\")\n        return self._session_factories[name]\n\n    @property\n    def engine(self) -&gt; AsyncEngine:\n        \"\"\"Access the default SQLAlchemy AsyncEngine.\"\"\"\n        return self.get_engine(DEFAULT_DB_NAME)\n\n    @property\n    def session_factory(self) -&gt; async_sessionmaker[AsyncSession]:\n        \"\"\"Access the default AsyncSession factory.\"\"\"\n        return self.get_factory(DEFAULT_DB_NAME)\n\n    def setup(\n        self,\n        database_url: str,\n        name: str = DEFAULT_DB_NAME,\n        echo: bool = False,\n        pool_size: int = 10,\n        max_overflow: int = 20,\n        pool_pre_ping: bool = True,\n        connect_args: Optional[dict] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Initialize an Async Engine and Session Factory with a specific name.\"\"\"\n        if name in self._engines:\n            logger.warning(f\"Database '{name}' is already configured, skipping duplicate setup.\")\n            return\n\n        engine_args = {\n            \"echo\": echo,\n            \"pool_pre_ping\": pool_pre_ping,\n            \"connect_args\": connect_args or {},\n            **kwargs,\n        }\n\n        if \"sqlite\" not in database_url:\n            engine_args[\"pool_size\"] = pool_size\n            engine_args[\"max_overflow\"] = max_overflow\n\n        engine = create_async_engine(database_url, **engine_args)\n        factory = async_sessionmaker(\n            bind=engine,\n            class_=AsyncSession,\n            expire_on_commit=False,\n            autoflush=False,\n        )\n\n        self._engines[name] = engine\n        self._session_factories[name] = factory\n        logger.info(f\"Database '{name}' initialized successfully.\")\n\n    async def shutdown(self) -&gt; None:\n        \"\"\"Dispose of all registered engines and clear factories.\"\"\"\n        for engine in self._engines.values():\n            await engine.dispose()\n        self._engines.clear()\n        self._session_factories.clear()\n\n    @asynccontextmanager\n    async def session(self, name: str = DEFAULT_DB_NAME) -&gt; AsyncGenerator[AsyncSession, None]:\n        \"\"\"\n        Context Manager for obtaining a NEW database session from a specific engine.\n\n        Note:\n            This context manager does NOT auto-commit. You must explicitly call\n            `await session.commit()` to persist changes to the database.\n\n        Example:\n            ```python\n            async with db.session() as session:\n                session.add(user)\n                await session.commit()  # Required to persist changes\n            ```\n        \"\"\"\n        async with manage_session(self.get_factory(name)) as session:\n            yield session\n\n    async def verify(self, name: str = DEFAULT_DB_NAME) -&gt; bool:\n        \"\"\"\n        Verify the database connection is working.\n\n        Args:\n            name: The database name to verify.\n\n        Returns:\n            True if connection is successful.\n\n        Raises:\n            RuntimeError: If the database is not initialized.\n            Exception: If the connection test fails.\n        \"\"\"\n        async with self.session(name) as session:\n            await session.execute(text(\"SELECT 1\"))\n        logger.info(f\"Database '{name}' connection verified.\")\n        return True\n\n    async def create_all(self, name: str = DEFAULT_DB_NAME, metadata: Any = None) -&gt; None:\n        \"\"\"\n        Create tables in the database.\n\n        Args:\n            name: The database name to create tables in.\n            metadata: SQLAlchemy MetaData object. If None, uses SQLModel.metadata\n                      which includes ALL registered models. For production, consider\n                      using Alembic migrations instead.\n\n        Example:\n            ```python\n            # Development: create all tables\n            await db.create_all()\n\n            # With custom metadata (only specific tables)\n            from sqlalchemy import MetaData\n            my_metadata = MetaData()\n            await db.create_all(metadata=my_metadata)\n            ```\n        \"\"\"\n        target_metadata = metadata if metadata is not None else SQLModel.metadata\n        async with self.get_engine(name).begin() as conn:\n            await conn.run_sync(target_metadata.create_all)\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.engine","title":"<code>engine</code>  <code>property</code>","text":"<p>Access the default SQLAlchemy AsyncEngine.</p>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.session_factory","title":"<code>session_factory</code>  <code>property</code>","text":"<p>Access the default AsyncSession factory.</p>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.create_all","title":"<code>create_all(name=DEFAULT_DB_NAME, metadata=None)</code>  <code>async</code>","text":"<p>Create tables in the database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The database name to create tables in.</p> <code>DEFAULT_DB_NAME</code> <code>metadata</code> <code>Any</code> <p>SQLAlchemy MetaData object. If None, uses SQLModel.metadata       which includes ALL registered models. For production, consider       using Alembic migrations instead.</p> <code>None</code> Example <pre><code># Development: create all tables\nawait db.create_all()\n\n# With custom metadata (only specific tables)\nfrom sqlalchemy import MetaData\nmy_metadata = MetaData()\nawait db.create_all(metadata=my_metadata)\n</code></pre> Source code in <code>zodiac_core/db/session.py</code> <pre><code>async def create_all(self, name: str = DEFAULT_DB_NAME, metadata: Any = None) -&gt; None:\n    \"\"\"\n    Create tables in the database.\n\n    Args:\n        name: The database name to create tables in.\n        metadata: SQLAlchemy MetaData object. If None, uses SQLModel.metadata\n                  which includes ALL registered models. For production, consider\n                  using Alembic migrations instead.\n\n    Example:\n        ```python\n        # Development: create all tables\n        await db.create_all()\n\n        # With custom metadata (only specific tables)\n        from sqlalchemy import MetaData\n        my_metadata = MetaData()\n        await db.create_all(metadata=my_metadata)\n        ```\n    \"\"\"\n    target_metadata = metadata if metadata is not None else SQLModel.metadata\n    async with self.get_engine(name).begin() as conn:\n        await conn.run_sync(target_metadata.create_all)\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.get_engine","title":"<code>get_engine(name=DEFAULT_DB_NAME)</code>","text":"<p>Access a specific SQLAlchemy AsyncEngine by name.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>def get_engine(self, name: str = DEFAULT_DB_NAME) -&gt; AsyncEngine:\n    \"\"\"Access a specific SQLAlchemy AsyncEngine by name.\"\"\"\n    if name not in self._engines:\n        raise RuntimeError(f\"Database engine '{name}' is not initialized. Call db.setup(name='{name}') first.\")\n    return self._engines[name]\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.get_factory","title":"<code>get_factory(name=DEFAULT_DB_NAME)</code>","text":"<p>Access a specific AsyncSession factory by name.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>def get_factory(self, name: str = DEFAULT_DB_NAME) -&gt; async_sessionmaker[AsyncSession]:\n    \"\"\"Access a specific AsyncSession factory by name.\"\"\"\n    if name not in self._session_factories:\n        raise RuntimeError(f\"Session factory for '{name}' is not initialized. Call db.setup(name='{name}') first.\")\n    return self._session_factories[name]\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.session","title":"<code>session(name=DEFAULT_DB_NAME)</code>  <code>async</code>","text":"<p>Context Manager for obtaining a NEW database session from a specific engine.</p> Note <p>This context manager does NOT auto-commit. You must explicitly call <code>await session.commit()</code> to persist changes to the database.</p> Example <pre><code>async with db.session() as session:\n    session.add(user)\n    await session.commit()  # Required to persist changes\n</code></pre> Source code in <code>zodiac_core/db/session.py</code> <pre><code>@asynccontextmanager\nasync def session(self, name: str = DEFAULT_DB_NAME) -&gt; AsyncGenerator[AsyncSession, None]:\n    \"\"\"\n    Context Manager for obtaining a NEW database session from a specific engine.\n\n    Note:\n        This context manager does NOT auto-commit. You must explicitly call\n        `await session.commit()` to persist changes to the database.\n\n    Example:\n        ```python\n        async with db.session() as session:\n            session.add(user)\n            await session.commit()  # Required to persist changes\n        ```\n    \"\"\"\n    async with manage_session(self.get_factory(name)) as session:\n        yield session\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.setup","title":"<code>setup(database_url, name=DEFAULT_DB_NAME, echo=False, pool_size=10, max_overflow=20, pool_pre_ping=True, connect_args=None, **kwargs)</code>","text":"<p>Initialize an Async Engine and Session Factory with a specific name.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>def setup(\n    self,\n    database_url: str,\n    name: str = DEFAULT_DB_NAME,\n    echo: bool = False,\n    pool_size: int = 10,\n    max_overflow: int = 20,\n    pool_pre_ping: bool = True,\n    connect_args: Optional[dict] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialize an Async Engine and Session Factory with a specific name.\"\"\"\n    if name in self._engines:\n        logger.warning(f\"Database '{name}' is already configured, skipping duplicate setup.\")\n        return\n\n    engine_args = {\n        \"echo\": echo,\n        \"pool_pre_ping\": pool_pre_ping,\n        \"connect_args\": connect_args or {},\n        **kwargs,\n    }\n\n    if \"sqlite\" not in database_url:\n        engine_args[\"pool_size\"] = pool_size\n        engine_args[\"max_overflow\"] = max_overflow\n\n    engine = create_async_engine(database_url, **engine_args)\n    factory = async_sessionmaker(\n        bind=engine,\n        class_=AsyncSession,\n        expire_on_commit=False,\n        autoflush=False,\n    )\n\n    self._engines[name] = engine\n    self._session_factories[name] = factory\n    logger.info(f\"Database '{name}' initialized successfully.\")\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.shutdown","title":"<code>shutdown()</code>  <code>async</code>","text":"<p>Dispose of all registered engines and clear factories.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Dispose of all registered engines and clear factories.\"\"\"\n    for engine in self._engines.values():\n        await engine.dispose()\n    self._engines.clear()\n    self._session_factories.clear()\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.verify","title":"<code>verify(name=DEFAULT_DB_NAME)</code>  <code>async</code>","text":"<p>Verify the database connection is working.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The database name to verify.</p> <code>DEFAULT_DB_NAME</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if connection is successful.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the database is not initialized.</p> <code>Exception</code> <p>If the connection test fails.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>async def verify(self, name: str = DEFAULT_DB_NAME) -&gt; bool:\n    \"\"\"\n    Verify the database connection is working.\n\n    Args:\n        name: The database name to verify.\n\n    Returns:\n        True if connection is successful.\n\n    Raises:\n        RuntimeError: If the database is not initialized.\n        Exception: If the connection test fails.\n    \"\"\"\n    async with self.session(name) as session:\n        await session.execute(text(\"SELECT 1\"))\n    logger.info(f\"Database '{name}' connection verified.\")\n    return True\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.get_session","title":"<code>get_session()</code>  <code>async</code>","text":"<p>FastAPI Dependency for obtaining a default database session.</p> Note <p>This dependency does NOT auto-commit. You must explicitly call <code>await session.commit()</code> within your endpoint to persist changes.</p> Example <pre><code>@app.post(\"/users\")\nasync def create_user(session: AsyncSession = Depends(get_session)):\n    user = User(name=\"test\")\n    session.add(user)\n    await session.commit()  # Required to persist changes\n    return user\n</code></pre> Source code in <code>zodiac_core/db/session.py</code> <pre><code>async def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    \"\"\"\n    FastAPI Dependency for obtaining a default database session.\n\n    Note:\n        This dependency does NOT auto-commit. You must explicitly call\n        `await session.commit()` within your endpoint to persist changes.\n\n    Example:\n        ```python\n        @app.post(\"/users\")\n        async def create_user(session: AsyncSession = Depends(get_session)):\n            user = User(name=\"test\")\n            session.add(user)\n            await session.commit()  # Required to persist changes\n            return user\n        ```\n    \"\"\"\n    async with db.session() as session:\n        yield session\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.init_db_resource","title":"<code>init_db_resource(database_url, name=DEFAULT_DB_NAME, echo=False, connect_args=None, **kwargs)</code>  <code>async</code>","text":"<p>A helper for dependency_injector's Resource provider. Handles the setup and shutdown lifecycle of the global <code>db</code> instance.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>async def init_db_resource(\n    database_url: str,\n    name: str = DEFAULT_DB_NAME,\n    echo: bool = False,\n    connect_args: Optional[dict] = None,\n    **kwargs,\n) -&gt; AsyncGenerator[DatabaseManager, None]:\n    \"\"\"\n    A helper for dependency_injector's Resource provider.\n    Handles the setup and shutdown lifecycle of the global `db` instance.\n    \"\"\"\n    db.setup(database_url=database_url, name=name, echo=echo, connect_args=connect_args, **kwargs)\n    try:\n        yield db\n    finally:\n        await db.shutdown()\n</code></pre>"},{"location":"api/db/#repository-base","title":"Repository Base","text":""},{"location":"api/db/#zodiac_core.db.repository.BaseSQLRepository","title":"<code>zodiac_core.db.repository.BaseSQLRepository</code>","text":"<p>Standard base class for SQL-based repositories.</p> <p>Supports multiple database instances via <code>db_name</code>.</p> Source code in <code>zodiac_core/db/repository.py</code> <pre><code>class BaseSQLRepository:\n    \"\"\"\n    Standard base class for SQL-based repositories.\n\n    Supports multiple database instances via `db_name`.\n    \"\"\"\n\n    def __init__(\n        self,\n        session_factory: Optional[async_sessionmaker[AsyncSession]] = None,\n        db_name: str = DEFAULT_DB_NAME,\n        options: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the repository.\n\n        Args:\n            session_factory: Optional custom session factory. If provided, db_name is ignored.\n            db_name: The name of the database engine registered in db.setup(). Defaults to DEFAULT_DB_NAME (\"default\").\n            options: Optional configuration/options for the repository.\n        \"\"\"\n        self._session_factory = session_factory\n        self.db_name = db_name\n        self.options = options\n\n    @asynccontextmanager\n    async def session(self) -&gt; AsyncIterator[AsyncSession]:\n        \"\"\"\n        Async context manager for obtaining a database session.\n        Uses the injected factory or resolves one from the global 'db' via 'db_name'.\n\n        Note:\n            This context manager does NOT auto-commit. You must explicitly call\n            `await session.commit()` to persist changes to the database.\n        \"\"\"\n        factory = self._session_factory or db.get_factory(self.db_name)\n        async with manage_session(factory) as session:\n            yield session\n</code></pre>"},{"location":"api/db/#zodiac_core.db.repository.BaseSQLRepository.__init__","title":"<code>__init__(session_factory=None, db_name=DEFAULT_DB_NAME, options=None)</code>","text":"<p>Initialize the repository.</p> <p>Parameters:</p> Name Type Description Default <code>session_factory</code> <code>Optional[async_sessionmaker[AsyncSession]]</code> <p>Optional custom session factory. If provided, db_name is ignored.</p> <code>None</code> <code>db_name</code> <code>str</code> <p>The name of the database engine registered in db.setup(). Defaults to DEFAULT_DB_NAME (\"default\").</p> <code>DEFAULT_DB_NAME</code> <code>options</code> <code>Optional[Any]</code> <p>Optional configuration/options for the repository.</p> <code>None</code> Source code in <code>zodiac_core/db/repository.py</code> <pre><code>def __init__(\n    self,\n    session_factory: Optional[async_sessionmaker[AsyncSession]] = None,\n    db_name: str = DEFAULT_DB_NAME,\n    options: Optional[Any] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the repository.\n\n    Args:\n        session_factory: Optional custom session factory. If provided, db_name is ignored.\n        db_name: The name of the database engine registered in db.setup(). Defaults to DEFAULT_DB_NAME (\"default\").\n        options: Optional configuration/options for the repository.\n    \"\"\"\n    self._session_factory = session_factory\n    self.db_name = db_name\n    self.options = options\n</code></pre>"},{"location":"api/db/#zodiac_core.db.repository.BaseSQLRepository.session","title":"<code>session()</code>  <code>async</code>","text":"<p>Async context manager for obtaining a database session. Uses the injected factory or resolves one from the global 'db' via 'db_name'.</p> Note <p>This context manager does NOT auto-commit. You must explicitly call <code>await session.commit()</code> to persist changes to the database.</p> Source code in <code>zodiac_core/db/repository.py</code> <pre><code>@asynccontextmanager\nasync def session(self) -&gt; AsyncIterator[AsyncSession]:\n    \"\"\"\n    Async context manager for obtaining a database session.\n    Uses the injected factory or resolves one from the global 'db' via 'db_name'.\n\n    Note:\n        This context manager does NOT auto-commit. You must explicitly call\n        `await session.commit()` to persist changes to the database.\n    \"\"\"\n    factory = self._session_factory or db.get_factory(self.db_name)\n    async with manage_session(factory) as session:\n        yield session\n</code></pre>"},{"location":"api/db/#sql-models-mixins","title":"SQL Models &amp; Mixins","text":""},{"location":"api/db/#zodiac_core.db.sql","title":"<code>zodiac_core.db.sql</code>","text":""},{"location":"api/db/#zodiac_core.db.sql.IntIDModel","title":"<code>IntIDModel</code>","text":"<p>               Bases: <code>SQLBase</code>, <code>IntIDMixin</code></p> <p>Base SQLModel with Integer ID and Timestamps. Includes: ID (int) + CreatedAt + UpdatedAt.</p> Source code in <code>zodiac_core/db/sql.py</code> <pre><code>class IntIDModel(SQLBase, IntIDMixin):\n    \"\"\"\n    Base SQLModel with Integer ID and Timestamps.\n    Includes: ID (int) + CreatedAt + UpdatedAt.\n    \"\"\"\n</code></pre>"},{"location":"api/db/#zodiac_core.db.sql.UUIDModel","title":"<code>UUIDModel</code>","text":"<p>               Bases: <code>SQLBase</code>, <code>UUIDMixin</code></p> <p>Base SQLModel with UUID and Timestamps. Includes: ID (UUID) + CreatedAt + UpdatedAt.</p> Source code in <code>zodiac_core/db/sql.py</code> <pre><code>class UUIDModel(SQLBase, UUIDMixin):\n    \"\"\"\n    Base SQLModel with UUID and Timestamps.\n    Includes: ID (UUID) + CreatedAt + UpdatedAt.\n    \"\"\"\n</code></pre>"},{"location":"api/db/#zodiac_core.db.sql.SQLDateTimeMixin","title":"<code>SQLDateTimeMixin</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Mixin for created_at and updated_at with SQLAlchemy server-side defaults. Supports PostgreSQL, MySQL, and SQLite with proper UTC handling.</p> Source code in <code>zodiac_core/db/sql.py</code> <pre><code>class SQLDateTimeMixin(SQLModel):\n    \"\"\"\n    Mixin for created_at and updated_at with SQLAlchemy server-side defaults.\n    Supports PostgreSQL, MySQL, and SQLite with proper UTC handling.\n    \"\"\"\n\n    created_at: datetime = Field(\n        default_factory=utc_now,\n        sa_column_kwargs={\n            \"server_default\": utcnow(),\n            \"nullable\": False,\n        },\n        sa_type=DateTime(timezone=True),\n        description=\"Record creation timestamp (UTC)\",\n    )\n    updated_at: datetime = Field(\n        default_factory=utc_now,\n        sa_column_kwargs={\n            \"server_default\": utcnow(),\n            \"onupdate\": utcnow(),\n            \"nullable\": False,\n        },\n        sa_type=DateTime(timezone=True),\n        description=\"Record last update timestamp (UTC)\",\n    )\n</code></pre>"},{"location":"api/exceptions/","title":"Exception Handling","text":"<p>ZodiacCore provides a centralized exception handling system that automatically converts Python exceptions into standardized, production-ready JSON responses.</p>"},{"location":"api/exceptions/#1-core-concepts","title":"1. Core Concepts","text":""},{"location":"api/exceptions/#the-zodiacexception-base","title":"The ZodiacException Base","text":"<p>All business logic errors should inherit from <code>ZodiacException</code>. This base class allows you to define:</p> <ul> <li><code>http_code</code>: The HTTP status code (e.g., 404, 400).</li> <li><code>code</code>: A custom business error code.</li> <li><code>message</code>: A human-readable error description.</li> <li><code>data</code>: Optional payload for additional error details (e.g., validation errors).</li> </ul>"},{"location":"api/exceptions/#automatic-transformation","title":"Automatic Transformation","text":"<p>When a <code>ZodiacException</code> is raised, the <code>handler_zodiac_exception</code> exception handler catches it and transforms it into a standard JSON response:</p> <pre><code>{\n  \"code\": 404,\n  \"message\": \"Resource not found\",\n  \"data\": null\n}\n</code></pre>"},{"location":"api/exceptions/#2-validation-errors-http-422","title":"2. Validation Errors (HTTP 422)","text":"<p>One of the best features of ZodiacCore is that it also standardizes framework-level validation errors. When a user sends invalid JSON or missing parameters, FastAPI normally returns a custom structure. ZodiacCore catches these and wraps them in our standard format:</p> <pre><code>{\n  \"code\": 422,\n  \"message\": \"Unprocessable Entity\",\n  \"data\": [\n    {\n      \"type\": \"missing\",\n      \"loc\": [\"body\", \"username\"],\n      \"msg\": \"Field required\",\n      \"input\": null\n    }\n  ]\n}\n</code></pre> <p>This ensures your API is 100% consistent, whether the error came from your business logic or from a schema mismatch.</p>"},{"location":"api/exceptions/#3-built-in-exceptions","title":"3. Built-in Exceptions","text":"<p>ZodiacCore includes several common exceptions ready to use:</p> Exception HTTP Status Use Case <code>BadRequestException</code> 400 Invalid input or parameters. <code>UnauthorizedException</code> 401 Missing or invalid authentication. <code>ForbiddenException</code> 403 Insufficient permissions. <code>NotFoundException</code> 404 Resource does not exist. <code>ConflictException</code> 409 Resource state conflict (e.g., duplicate entry)."},{"location":"api/exceptions/#4-custom-exceptions","title":"4. Custom Exceptions","text":"<p>Creating your own business exception is simple:</p> <pre><code>from zodiac_core.exceptions import ZodiacException\nfrom fastapi import status\n\nclass InsufficientBalanceException(ZodiacException):\n    # Set default HTTP code\n    http_code = status.HTTP_400_BAD_REQUEST\n\n    def __init__(self, current_balance: float):\n        super().__init__(\n            code=1001, # Custom business code\n            message=\"Your account balance is too low.\",\n            data={\"current_balance\": current_balance}\n        )\n</code></pre> <p>Usage in a route: <pre><code>@app.post(\"/transfer\")\nasync def transfer_money(amount: float):\n    if amount &gt; user.balance:\n        raise InsufficientBalanceException(user.balance)\n    ...\n</code></pre></p>"},{"location":"api/exceptions/#5-integration","title":"5. Integration","text":"<p>To enable global exception handling in your FastAPI app, use <code>register_exception_handlers</code>. This will catch:</p> <ol> <li>All <code>ZodiacException</code> subclasses.</li> <li>Pydantic <code>ValidationError</code> and FastAPI <code>RequestValidationError</code> (mapped to 422).</li> <li>Any uncaught <code>Exception</code> (mapped to 500 with secure logging).</li> </ol> <pre><code>from fastapi import FastAPI\nfrom zodiac_core.exception_handlers import register_exception_handlers\n\napp = FastAPI()\nregister_exception_handlers(app)\n</code></pre>"},{"location":"api/exceptions/#6-api-reference","title":"6. API Reference","text":""},{"location":"api/exceptions/#exception-base-subclasses","title":"Exception Base &amp; Subclasses","text":""},{"location":"api/exceptions/#zodiac_core.exceptions.ZodiacException","title":"<code>ZodiacException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all zodiac-core related errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class ZodiacException(Exception):\n    \"\"\"Base class for all zodiac-core related errors.\"\"\"\n\n    http_code: int = status.HTTP_500_INTERNAL_SERVER_ERROR\n\n    def __init__(\n        self,\n        code: Optional[int] = None,\n        data: Any = None,\n        message: Optional[str] = None,\n    ):\n        self.code = code or self.http_code\n        self.data = data\n        if message is not None:\n            self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"api/exceptions/#zodiac_core.exceptions.BadRequestException","title":"<code>BadRequestException</code>","text":"<p>               Bases: <code>ZodiacException</code></p> <p>Exception raised for 400 Bad Request errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class BadRequestException(ZodiacException):\n    \"\"\"Exception raised for 400 Bad Request errors.\"\"\"\n\n    http_code = status.HTTP_400_BAD_REQUEST\n</code></pre>"},{"location":"api/exceptions/#zodiac_core.exceptions.UnauthorizedException","title":"<code>UnauthorizedException</code>","text":"<p>               Bases: <code>ZodiacException</code></p> <p>Exception raised for 401 Unauthorized errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class UnauthorizedException(ZodiacException):\n    \"\"\"Exception raised for 401 Unauthorized errors.\"\"\"\n\n    http_code = status.HTTP_401_UNAUTHORIZED\n</code></pre>"},{"location":"api/exceptions/#zodiac_core.exceptions.ForbiddenException","title":"<code>ForbiddenException</code>","text":"<p>               Bases: <code>ZodiacException</code></p> <p>Exception raised for 403 Forbidden errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class ForbiddenException(ZodiacException):\n    \"\"\"Exception raised for 403 Forbidden errors.\"\"\"\n\n    http_code = status.HTTP_403_FORBIDDEN\n</code></pre>"},{"location":"api/exceptions/#zodiac_core.exceptions.NotFoundException","title":"<code>NotFoundException</code>","text":"<p>               Bases: <code>ZodiacException</code></p> <p>Exception raised for 404 Not Found errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class NotFoundException(ZodiacException):\n    \"\"\"Exception raised for 404 Not Found errors.\"\"\"\n\n    http_code = status.HTTP_404_NOT_FOUND\n</code></pre>"},{"location":"api/exceptions/#zodiac_core.exceptions.ConflictException","title":"<code>ConflictException</code>","text":"<p>               Bases: <code>ZodiacException</code></p> <p>Exception raised for 409 Conflict errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class ConflictException(ZodiacException):\n    \"\"\"Exception raised for 409 Conflict errors.\"\"\"\n\n    http_code = status.HTTP_409_CONFLICT\n</code></pre>"},{"location":"api/exceptions/#global-handler-registration","title":"Global Handler Registration","text":""},{"location":"api/exceptions/#zodiac_core.exception_handlers.register_exception_handlers","title":"<code>register_exception_handlers(app)</code>","text":"<p>Register all exception handlers to the FastAPI app.</p> <p>Order matters: 1. Specific Validation Errors 2. Custom Business Logic Errors (ZodiacException) 3. Global Catch-All (Exception)</p> Source code in <code>zodiac_core/exception_handlers.py</code> <pre><code>def register_exception_handlers(app: FastAPI) -&gt; None:\n    \"\"\"\n    Register all exception handlers to the FastAPI app.\n\n    Order matters:\n    1. Specific Validation Errors\n    2. Custom Business Logic Errors (ZodiacException)\n    3. Global Catch-All (Exception)\n    \"\"\"\n    app.add_exception_handler(RequestValidationError, handler_validation_exception)\n    app.add_exception_handler(ValidationError, handler_validation_exception)\n    app.add_exception_handler(ZodiacException, handler_zodiac_exception)\n    app.add_exception_handler(Exception, handler_global_exception)\n</code></pre>"},{"location":"api/logging/","title":"Logging &amp; Observability","text":"<p>ZodiacCore provides a pre-configured, production-ready logging system based on Loguru. It is designed for observability, supporting JSON structured logs and automatic Trace ID correlation.</p>"},{"location":"api/logging/#1-core-concepts","title":"1. Core Concepts","text":""},{"location":"api/logging/#structured-logging","title":"Structured Logging","text":"<p>By default, ZodiacCore outputs logs in JSON format. This is ideal for production environments (e.g., ELK stack, Datadog, CloudWatch) as it makes log parsing and searching significantly easier.</p>"},{"location":"api/logging/#trace-id-correlation","title":"Trace ID Correlation","text":"<p>Every log message automatically includes a <code>request_id</code> if it was generated during an active web request. This allows you to correlate multiple log lines across different services for a single transaction.</p>"},{"location":"api/logging/#2-quick-setup","title":"2. Quick Setup","text":"<p>The most common way to initialize logging is in your application's entry point (<code>main.py</code>).</p> <pre><code>from zodiac_core.logging import setup_loguru\n\nsetup_loguru(\n    level=\"INFO\",\n    json_format=True,        # Use JSON for production\n    service_name=\"payment-service\"\n)\n</code></pre>"},{"location":"api/logging/#3-advanced-configuration","title":"3. Advanced Configuration","text":""},{"location":"api/logging/#console-file-output","title":"Console &amp; File Output","text":"<p>You can log to both the console and a file simultaneously.</p> <pre><code>from zodiac_core.logging import setup_loguru, LogFileOptions\n\nsetup_loguru(\n    level=\"DEBUG\",\n    json_format=False,       # Use human-readable text for local dev\n    log_file=\"logs/app.log\",\n    file_options=LogFileOptions(\n        rotation=\"500 MB\",\n        retention=\"10 days\",\n        compression=\"zip\"\n    )\n)\n</code></pre>"},{"location":"api/logging/#passing-extra-sink-options","title":"Passing Extra Sink Options","text":"<p>The <code>console_options</code> argument allows you to pass arbitrary keyword arguments directly to the Loguru <code>add()</code> method.</p> <pre><code>setup_loguru(\n    console_options={\"enqueue\": True, \"backtrace\": True, \"diagnose\": True}\n)\n</code></pre>"},{"location":"api/logging/#4-how-to-log","title":"4. How to Log","text":"<p>Since ZodiacCore configures the standard <code>loguru.logger</code>, you can simply import and use it anywhere in your code.</p> <pre><code>from loguru import logger\n\ndef process_data(data):\n    logger.info(\"Processing data\", extra={\"data_id\": data.id})\n    # If this runs during a request, 'request_id' is automatically added!\n</code></pre>"},{"location":"api/logging/#5-json-log-structure","title":"5. JSON Log Structure","text":"<p>A typical JSON log entry produced by ZodiacCore looks like this:</p> <pre><code>{\n  \"text\": \"2026-01-31 17:26:24.208 | INFO     | demo_r:read_item:23 - request: item_id=1\\n\",\n  \"record\": {\n    \"elapsed\": {\n      \"repr\": \"0:00:14.429585\",\n      \"seconds\": 14.429585\n    },\n    \"exception\": null,\n    \"extra\": {\n      \"request_id\": \"98277dc9-27ca-4849-98f0-6097c3b41867\",\n      \"service\": \"service\"\n    },\n    \"file\": {\n      \"name\": \"demo_r.py\",\n      \"path\": \"/Users/legolas/workspace/ZodiacCore-Py/demo_r.py\"\n    },\n    \"function\": \"read_item\",\n    \"level\": {\n      \"icon\": \"\u2139\ufe0f\",\n      \"name\": \"INFO\",\n      \"no\": 20\n    },\n    \"line\": 23,\n    \"message\": \"request: item_id=1\",\n    \"module\": \"demo_r\",\n    \"name\": \"demo_r\",\n    \"process\": {\n      \"id\": 92473,\n      \"name\": \"MainProcess\"\n    },\n    \"thread\": {\n      \"id\": 140704462000000,\n      \"name\": \"MainThread\"\n    },\n    \"time\": {\n      \"repr\": \"2026-01-31 17:26:24.208560+08:00\",\n      \"timestamp\": 1769851584.20856\n    }\n  }\n}\n</code></pre>"},{"location":"api/logging/#6-api-reference","title":"6. API Reference","text":""},{"location":"api/logging/#logging-utilities","title":"Logging Utilities","text":""},{"location":"api/logging/#zodiac_core.logging.LogFileOptions","title":"<code>LogFileOptions</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration options for file logging.</p> <p>Allows arbitrary extra arguments to be passed to loguru.add() via extra=\"allow\".</p> Source code in <code>zodiac_core/logging.py</code> <pre><code>class LogFileOptions(BaseModel):\n    \"\"\"\n    Configuration options for file logging.\n\n    Allows arbitrary extra arguments to be passed to loguru.add() via extra=\"allow\".\n    \"\"\"\n\n    rotation: str = \"10 MB\"\n    retention: str = \"1 week\"\n    compression: str = \"zip\"\n    enqueue: bool = False\n    encoding: str = \"utf-8\"\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/logging/#zodiac_core.logging.setup_loguru","title":"<code>setup_loguru(level='INFO', json_format=True, service_name='service', log_file=None, console_options=None, file_options=None)</code>","text":"<p>Configure Loguru with automatic Trace ID injection and multi-destination output.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>Logging level (INFO, DEBUG, etc.)</p> <code>'INFO'</code> <code>json_format</code> <code>bool</code> <p>Whether to output JSON (True) or Text (False).</p> <code>True</code> <code>service_name</code> <code>str</code> <p>Name of the service (added to JSON logs).</p> <code>'service'</code> <code>log_file</code> <code>Optional[str]</code> <p>Optional file path to save logs.</p> <code>None</code> <code>console_options</code> <code>Optional[Dict[str, Any]]</code> <p>Extra kwargs to pass to the console sink (e.g. {\"enqueue\": True}).</p> <code>None</code> <code>file_options</code> <code>Optional[LogFileOptions]</code> <p>Configuration model (LogFileOptions) for file sink.</p> <code>None</code> Source code in <code>zodiac_core/logging.py</code> <pre><code>def setup_loguru(\n    level: str = \"INFO\",\n    json_format: bool = True,\n    service_name: str = \"service\",\n    log_file: Optional[str] = None,\n    console_options: Optional[Dict[str, Any]] = None,\n    file_options: Optional[LogFileOptions] = None,\n):\n    \"\"\"\n    Configure Loguru with automatic Trace ID injection and multi-destination output.\n\n    Args:\n        level: Logging level (INFO, DEBUG, etc.)\n        json_format: Whether to output JSON (True) or Text (False).\n        service_name: Name of the service (added to JSON logs).\n        log_file: Optional file path to save logs.\n        console_options: Extra kwargs to pass to the console sink (e.g. {\"enqueue\": True}).\n        file_options: Configuration model (LogFileOptions) for file sink.\n    \"\"\"\n    # 1. Remove default handlers\n    logger.remove()\n\n    service = service_name\n\n    # 2. Configure Patcher (Trace ID injection)\n    def patcher(record):\n        request_id = get_request_id()\n        if request_id:\n            record[\"extra\"][\"request_id\"] = request_id\n        record[\"extra\"][\"service\"] = service\n\n    logger.configure(patcher=patcher)\n\n    # 3. Define Formatters\n    def _dev_formatter(record):\n        if \"request_id\" not in record[\"extra\"]:\n            record[\"extra\"][\"request_id\"] = \"-\"\n        return (\n            \"&lt;green&gt;{time:YYYYMMDD HH:mm:ss}&lt;/green&gt; \"\n            \"| {extra[service]} \"\n            \"| {extra[request_id]} \"\n            \"| {process.name} \"\n            \"| {thread.name} \"\n            \"| &lt;cyan&gt;{module}&lt;/cyan&gt;.&lt;cyan&gt;{function}&lt;/cyan&gt; \"\n            \"| &lt;level&gt;{level}&lt;/level&gt;: \"\n            \"&lt;level&gt;{message}&lt;/level&gt; \"\n            \"| {file.path}:{line}\\n\"\n        )\n\n    # 4. Prepare Console Config\n    c_config = console_options or {}\n    c_config.setdefault(\"level\", level)\n    c_config.setdefault(\"sink\", sys.stderr)\n    c_config.setdefault(\"enqueue\", True)  # Use thread-safe queue\n\n    if json_format:\n        c_config.setdefault(\"serialize\", True)\n    else:\n        c_config.setdefault(\"format\", _dev_formatter)\n\n    # Add Console Sink\n    logger.add(**c_config)\n\n    # 5. Prepare File Config (if enabled)\n    if log_file:\n        if file_options is None:\n            file_options = LogFileOptions()\n        f_config = file_options.model_dump()\n\n        # Ensure mandatory defaults\n        f_config.setdefault(\"sink\", log_file)\n        f_config.setdefault(\"level\", level)\n        f_config.setdefault(\"enqueue\", True)\n\n        if json_format:\n            f_config.setdefault(\"serialize\", True)\n        else:\n            f_config.setdefault(\"format\", _dev_formatter)\n\n        # Add File Sink\n        logger.add(**f_config)\n</code></pre>"},{"location":"api/middleware/","title":"Middleware Stack","text":"<p>ZodiacCore provides a standard stack of middlewares to handle cross-cutting concerns like request tracing, latency monitoring, and access logging.</p>"},{"location":"api/middleware/#1-core-middlewares","title":"1. Core Middlewares","text":""},{"location":"api/middleware/#trace-id-middleware","title":"Trace ID Middleware","text":"<p>The <code>TraceIDMiddleware</code> is the entry point for observability. It:</p> <ol> <li>Reads: Looks for an <code>X-Request-ID</code> header in the incoming request.</li> <li>Generates: If missing, it generates a fresh UUID.</li> <li>Persists: Sets the ID in the request context (via <code>zodiac_core.context</code>).</li> <li>Responds: Attaches the same ID to the response headers for frontend tracking.</li> </ol>"},{"location":"api/middleware/#access-log-middleware","title":"Access Log Middleware","text":"<p>The <code>AccessLogMiddleware</code> records every HTTP transaction. It logs:</p> <ul> <li>HTTP Method and Path.</li> <li>Status Code.</li> <li>Processing Latency (in milliseconds).</li> <li>The associated Trace ID (automatically picked up from the context).</li> </ul>"},{"location":"api/middleware/#2-usage-order","title":"2. Usage &amp; Order","text":"<p>The simplest way to use these is via <code>register_middleware</code>.</p> <p>Middleware Order</p> <p>ZodiacCore adds middlewares in a specific order to ensure that the Trace ID is generated before the Access Log tries to record it.</p> <pre><code>from fastapi import FastAPI\nfrom zodiac_core.middleware import register_middleware\n\napp = FastAPI()\n\n# Registers both TraceID and AccessLog middlewares in the correct order\nregister_middleware(app)\n</code></pre>"},{"location":"api/middleware/#3-customizing-trace-id-generation","title":"3. Customizing Trace ID Generation","text":"<p>If you want to use a custom header name or a different ID generator (e.g., K-Sorted IDs), you can add the middleware manually:</p> <pre><code>from zodiac_core.middleware import TraceIDMiddleware\n\napp.add_middleware(\n    TraceIDMiddleware,\n    header_name=\"X-Correlation-ID\",\n    generator=lambda: \"my-custom-id-123\"\n)\n</code></pre>"},{"location":"api/middleware/#4-api-reference","title":"4. API Reference","text":""},{"location":"api/middleware/#middleware-utilities","title":"Middleware Utilities","text":""},{"location":"api/middleware/#zodiac_core.middleware.TraceIDMiddleware","title":"<code>TraceIDMiddleware</code>","text":"<p>               Bases: <code>BaseHTTPMiddleware</code></p> <p>Loguru-compatible Trace ID Middleware.</p> <ol> <li>Extracts/Generates X-Request-ID.</li> <li>Sets it in a ContextVar (via zodiac_core.context).</li> <li>Appends it to the Response headers.</li> </ol> Source code in <code>zodiac_core/middleware.py</code> <pre><code>class TraceIDMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Loguru-compatible Trace ID Middleware.\n\n    1. Extracts/Generates X-Request-ID.\n    2. Sets it in a ContextVar (via zodiac_core.context).\n    3. Appends it to the Response headers.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: ASGIApp,\n        header_name: str = \"X-Request-ID\",\n        generator: Callable[[], str] = None,\n    ) -&gt; None:\n        super().__init__(app)\n        self.header_name = header_name\n        self.generator = generator or default_id_generator\n\n    async def dispatch(self, request: Request, call_next):\n        request_id = request.headers.get(self.header_name)\n        if request_id is None or len(request_id) != 36:\n            request_id = self.generator()\n\n        token = set_request_id(request_id)\n        try:\n            response = await call_next(request)\n            response.headers[self.header_name] = request_id\n            return response\n        finally:\n            reset_request_id(token)\n</code></pre>"},{"location":"api/middleware/#zodiac_core.middleware.AccessLogMiddleware","title":"<code>AccessLogMiddleware</code>","text":"<p>               Bases: <code>BaseHTTPMiddleware</code></p> <p>Standard Access Log Middleware.</p> <p>Logs request method, path, status code, and processing time (latency). Integrates with loguru (and will include request_id if TraceIDMiddleware is used).</p> Source code in <code>zodiac_core/middleware.py</code> <pre><code>class AccessLogMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Standard Access Log Middleware.\n\n    Logs request method, path, status code, and processing time (latency).\n    Integrates with loguru (and will include request_id if TraceIDMiddleware is used).\n    \"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.perf_counter()\n        response = await call_next(request)\n        process_time = (time.perf_counter() - start_time) * 1000\n\n        logger.info(\n            \"{method} {path} - {status_code} - {latency:.2f}ms\",\n            method=request.method,\n            path=request.url.path,\n            status_code=response.status_code,\n            latency=process_time,\n        )\n\n        return response\n</code></pre>"},{"location":"api/middleware/#zodiac_core.middleware.register_middleware","title":"<code>register_middleware(app)</code>","text":"<p>Register standard Zodiac middleware stack.</p> <p>Ensures correct order: 1. TraceIDMiddleware (Outer layer: generates ID) 2. AccessLogMiddleware (Inner layer: logs with ID)</p> Source code in <code>zodiac_core/middleware.py</code> <pre><code>def register_middleware(app: ASGIApp):\n    \"\"\"\n    Register standard Zodiac middleware stack.\n\n    Ensures correct order:\n    1. TraceIDMiddleware (Outer layer: generates ID)\n    2. AccessLogMiddleware (Inner layer: logs with ID)\n    \"\"\"\n    # Middleware is added in LIFO order (Last added is the Outer-most layer)\n\n    # 2. Inner: Access Log\n    app.add_middleware(AccessLogMiddleware)\n\n    # 1. Outer: Trace ID\n    app.add_middleware(TraceIDMiddleware)\n</code></pre>"},{"location":"api/pagination/","title":"Standard Pagination","text":"<p>ZodiacCore provides a set of Pydantic models to standardize how your API handles list-based data. It simplifies reading query parameters and ensures a consistent response structure for your frontend.</p>"},{"location":"api/pagination/#1-request-parameters","title":"1. Request Parameters","text":"<p>The <code>PageParams</code> model handles typical pagination query strings (<code>?page=1&amp;size=20</code>).</p> <pre><code>from typing import Annotated\nfrom fastapi import Query, Depends\nfrom zodiac_core.pagination import PageParams\n\n@app.get(\"/items\")\nasync def list_items(\n    params: Annotated[PageParams, Query()]\n):\n    # Automatically validated:\n    # params.page defaults to 1 (min 1)\n    # params.size defaults to 20 (max 100)\n\n    offset = (params.page - 1) * params.size\n    limit = params.size\n    ...\n</code></pre>"},{"location":"api/pagination/#2-standard-paged-response","title":"2. Standard Paged Response","text":"<p>The <code>PagedResponse[T]</code> is a generic model that wraps your data items along with metadata.</p>"},{"location":"api/pagination/#the-response-structure","title":"The Response Structure","text":"<pre><code>{\n  \"code\": 0,\n  \"message\": \"Success\",\n  \"data\": {\n    \"items\": [...],\n    \"total\": 100,\n    \"page\": 1,\n    \"size\": 20\n  }\n}\n</code></pre>"},{"location":"api/pagination/#building-the-response","title":"Building the Response","text":"<p>Use the <code>.create()</code> factory method to easily build the response from your query results and the input <code>PageParams</code>.</p> <pre><code>from zodiac_core.pagination import PagedResponse\nfrom .schemas import UserSchema\n\n@app.get(\"/users\", response_model=PagedResponse[UserSchema])\nasync def get_users(params: Annotated[PageParams, Query()]):\n    users, total_count = await db.find_users(params)\n\n    return PagedResponse.create(\n        items=users,\n        total=total_count,\n        params=params\n    )\n</code></pre>"},{"location":"api/pagination/#3-api-reference","title":"3. API Reference","text":""},{"location":"api/pagination/#pagination-models","title":"Pagination Models","text":""},{"location":"api/pagination/#zodiac_core.pagination.PageParams","title":"<code>PageParams</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Standard pagination query parameters.</p> Usage <pre><code>from typing import Annotated\nfrom fastapi import Query\nfrom zodiac_core.pagination import PageParams\n\n@app.get(\"/users\")\ndef list_users(page_params: Annotated[PageParams, Query()]):\n    skip = (page_params.page - 1) * page_params.size\n    limit = page_params.size\n    ...\n</code></pre> Source code in <code>zodiac_core/pagination.py</code> <pre><code>class PageParams(BaseModel):\n    \"\"\"\n    Standard pagination query parameters.\n\n    Usage:\n        ```python\n        from typing import Annotated\n        from fastapi import Query\n        from zodiac_core.pagination import PageParams\n\n        @app.get(\"/users\")\n        def list_users(page_params: Annotated[PageParams, Query()]):\n            skip = (page_params.page - 1) * page_params.size\n            limit = page_params.size\n            ...\n        ```\n    \"\"\"\n\n    page: int = Field(1, ge=1, description=\"Page number (1-based)\")\n    size: int = Field(20, ge=1, le=100, description=\"Page size\")\n</code></pre>"},{"location":"api/pagination/#zodiac_core.pagination.PagedResponse","title":"<code>PagedResponse</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>Standard generic paginated response model.</p> Usage <pre><code>from typing import Annotated\nfrom fastapi import Query\nfrom zodiac_core.pagination import PagedResponse, PageParams\n\n@app.get(\"/users\", response_model=PagedResponse[UserSchema])\ndef list_users(page_params: Annotated[PageParams, Query()]):\n    users, total_count = db.find_users(...)\n    return PagedResponse.create(users, total_count, page_params)\n</code></pre> Source code in <code>zodiac_core/pagination.py</code> <pre><code>class PagedResponse(BaseModel, Generic[T]):\n    \"\"\"\n    Standard generic paginated response model.\n\n    Usage:\n        ```python\n        from typing import Annotated\n        from fastapi import Query\n        from zodiac_core.pagination import PagedResponse, PageParams\n\n        @app.get(\"/users\", response_model=PagedResponse[UserSchema])\n        def list_users(page_params: Annotated[PageParams, Query()]):\n            users, total_count = db.find_users(...)\n            return PagedResponse.create(users, total_count, page_params)\n        ```\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    items: List[T] = Field(description=\"List of items for the current page\")\n    total: int = Field(description=\"Total number of items\")\n    page: int = Field(description=\"Current page number\")\n    size: int = Field(description=\"Current page size\")\n\n    @classmethod\n    def create(\n        cls,\n        items: List[T],\n        total: int,\n        params: PageParams,\n    ) -&gt; \"PagedResponse[T]\":\n        \"\"\"\n        Factory method to create a PagedResponse from items, total count, and PageParams.\n\n        Args:\n            items: The list of data objects (Pydantic models or dicts).\n            total: The total number of records in the database matching the query.\n            params: The PageParams object from the request.\n        \"\"\"\n        return cls(\n            items=items,\n            total=total,\n            page=params.page,\n            size=params.size,\n        )\n</code></pre>"},{"location":"api/pagination/#zodiac_core.pagination.PagedResponse.create","title":"<code>create(items, total, params)</code>  <code>classmethod</code>","text":"<p>Factory method to create a PagedResponse from items, total count, and PageParams.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[T]</code> <p>The list of data objects (Pydantic models or dicts).</p> required <code>total</code> <code>int</code> <p>The total number of records in the database matching the query.</p> required <code>params</code> <code>PageParams</code> <p>The PageParams object from the request.</p> required Source code in <code>zodiac_core/pagination.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    items: List[T],\n    total: int,\n    params: PageParams,\n) -&gt; \"PagedResponse[T]\":\n    \"\"\"\n    Factory method to create a PagedResponse from items, total count, and PageParams.\n\n    Args:\n        items: The list of data objects (Pydantic models or dicts).\n        total: The total number of records in the database matching the query.\n        params: The PageParams object from the request.\n    \"\"\"\n    return cls(\n        items=items,\n        total=total,\n        page=params.page,\n        size=params.size,\n    )\n</code></pre>"},{"location":"api/routing/","title":"Routing &amp; Response Wrapping","text":"<p>ZodiacCore enhances FastAPI's routing system to provide automatic response standardization. By using <code>APIRouter</code>, you ensure that every endpoint returns a consistent JSON structure without manual boilerplate.</p>"},{"location":"api/routing/#1-the-zodiac-apirouter","title":"1. The Zodiac APIRouter","text":"<p>The <code>APIRouter</code> in ZodiacCore is a drop-in replacement for <code>fastapi.APIRouter</code>. It uses a custom <code>ZodiacRoute</code> class that intercepts outgoing data and wraps it.</p>"},{"location":"api/routing/#automatic-wrapping","title":"Automatic Wrapping","text":"<p>When you return a dictionary, a Pydantic model, or a list from your route, Zodiac automatically wraps it in a <code>Response</code> model:</p> <pre><code>from zodiac_core.routing import APIRouter\n\nrouter = APIRouter()\n\n@router.get(\"/status\")\nasync def get_status():\n    return {\"status\": \"online\"}\n</code></pre> <p>Resulting JSON: <pre><code>{\n  \"code\": 0,\n  \"message\": \"Success\",\n  \"data\": {\n    \"status\": \"online\"\n  }\n}\n</code></pre></p>"},{"location":"api/routing/#2-standard-response-structure","title":"2. Standard Response Structure","text":"<p>All Zodiac responses follow this schema:</p> Field Type Description <code>code</code> <code>int</code> Business status code (0 for success). <code>message</code> <code>string</code> A brief description of the result. <code>data</code> <code>any</code> The actual payload (result of your function)."},{"location":"api/routing/#manual-responses","title":"Manual Responses","text":"<p>If you need to return a non-standard response (e.g., a FileResponse or a custom status code), you can still return raw FastAPI <code>Response</code> objects or Zodiac's <code>Response</code> class. If the return type is already a <code>Response</code>, Zodiac will not wrap it again.</p> <pre><code>from zodiac_core.response import response_ok\n\n@router.get(\"/custom\")\nasync def manual():\n    return response_ok(message=\"Custom success\", data={\"id\": 1})\n</code></pre>"},{"location":"api/routing/#3-openapi-integration","title":"3. OpenAPI Integration","text":"<p>ZodiacCore's <code>APIRouter</code> dynamically generates Pydantic models for your responses. This means your Swagger UI (<code>/docs</code>) will correctly display the wrapped structure, including the <code>code</code>, <code>message</code>, and <code>data</code> fields, mapped to your specific return type.</p>"},{"location":"api/routing/#4-api-reference","title":"4. API Reference","text":""},{"location":"api/routing/#routing-utilities","title":"Routing Utilities","text":""},{"location":"api/routing/#zodiac_core.routing.APIRouter","title":"<code>APIRouter</code>","text":"<p>               Bases: <code>APIRouter</code></p> <p>Zodiac-enhanced APIRouter that uses ZodiacRoute by default.</p> <p>All routes registered via this router will automatically: - Wrap response_model with Response[T] for OpenAPI docs - Wrap endpoint return values with Response structure</p> Source code in <code>zodiac_core/routing.py</code> <pre><code>class APIRouter(FastAPIRouter):\n    \"\"\"\n    Zodiac-enhanced APIRouter that uses ZodiacRoute by default.\n\n    All routes registered via this router will automatically:\n    - Wrap response_model with Response[T] for OpenAPI docs\n    - Wrap endpoint return values with Response structure\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault(\"route_class\", ZodiacRoute)\n        super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"api/routing/#zodiac_core.routing.ZodiacRoute","title":"<code>ZodiacRoute</code>","text":"<p>               Bases: <code>APIRoute</code></p> <p>Custom APIRoute that automatically wraps response models and endpoint returns with the standard Response[T] structure.</p> Source code in <code>zodiac_core/routing.py</code> <pre><code>class ZodiacRoute(APIRoute):\n    \"\"\"\n    Custom APIRoute that automatically wraps response models and endpoint returns\n    with the standard Response[T] structure.\n    \"\"\"\n\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Any = None,\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        **kwargs,\n    ) -&gt; None:\n        # Resolve FastAPI's DefaultPlaceholder\n        if isinstance(response_model, DefaultPlaceholder):\n            response_model = response_model.value\n\n        # 1. Wrap main response model (default to Any if missing)\n        if self._should_wrap(response_model):\n            response_model = self._wrap_response_model(response_model or Any)\n\n        # 2. Wrap additional responses (e.g. 400, 404 models)\n        # Copy to avoid mutating caller's dict\n        if responses:\n            responses = {code: {**res_dict} for code, res_dict in responses.items()}\n            for res in responses.values():\n                if \"model\" in res and self._should_wrap(res[\"model\"]):\n                    res[\"model\"] = self._wrap_response_model(res[\"model\"])\n\n        # 3. Wrap endpoint to auto-wrap return values\n        endpoint = self._wrap_endpoint(endpoint)\n\n        super().__init__(\n            path,\n            endpoint,\n            response_model=response_model,\n            responses=responses,\n            **kwargs,\n        )\n\n    @staticmethod\n    def _should_wrap(model: Any) -&gt; bool:\n        \"\"\"Check if a model needs to be wrapped with Response[T].\"\"\"\n        if model is Any or model is None:\n            return True\n        origin = get_origin(model)\n        if origin is Response:\n            return False\n        try:\n            if isinstance(model, type) and issubclass(model, Response):\n                return False\n        except TypeError:\n            pass\n        return True\n\n    @staticmethod\n    def _wrap_response_model(model: Any) -&gt; type[Response]:\n        \"\"\"Wrap a model type with Response[T] using Pydantic's native generics.\"\"\"\n        return Response[model]\n\n    @staticmethod\n    def _maybe_wrap_result(result: Any) -&gt; Any:\n        \"\"\"Wrap result in Response if not already a Response type.\"\"\"\n        if isinstance(result, (Response, FastAPIResponse)):\n            return result\n        return Response(data=result)\n\n    @staticmethod\n    def _wrap_endpoint(endpoint: Callable) -&gt; Callable:\n        \"\"\"Wrap endpoint to automatically wrap return values in Response.\"\"\"\n\n        @wraps(endpoint)\n        async def async_wrapper(*args, **kwargs):\n            result = await endpoint(*args, **kwargs)\n            return ZodiacRoute._maybe_wrap_result(result)\n\n        @wraps(endpoint)\n        def sync_wrapper(*args, **kwargs):\n            result = endpoint(*args, **kwargs)\n            return ZodiacRoute._maybe_wrap_result(result)\n\n        return async_wrapper if inspect.iscoroutinefunction(endpoint) else sync_wrapper\n</code></pre>"},{"location":"api/routing/#response-helpers","title":"Response Helpers","text":""},{"location":"api/routing/#zodiac_core.response.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>Standard API response model.</p> Source code in <code>zodiac_core/response.py</code> <pre><code>class Response(BaseModel, Generic[T]):\n    \"\"\"Standard API response model.\"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    code: int = Field(default=0, description=\"Business status code\")\n    data: Optional[T] = Field(default=None, description=\"Response payload\")\n    message: str = Field(default=\"Success\", description=\"Response message\")\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.create_response","title":"<code>create_response(http_code, code=None, data=None, message='')</code>","text":"<p>Create a standardized JSON response.</p> <p>Parameters:</p> Name Type Description Default <code>http_code</code> <code>int</code> <p>HTTP status code</p> required <code>code</code> <code>Optional[int]</code> <p>Business status code (defaults to http_code if not provided)</p> <code>None</code> <code>data</code> <code>Any</code> <p>Response payload</p> <code>None</code> <code>message</code> <code>str</code> <p>Response message</p> <code>''</code> Source code in <code>zodiac_core/response.py</code> <pre><code>def create_response(\n    http_code: int,\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"\",\n) -&gt; JSONResponse:\n    \"\"\"\n    Create a standardized JSON response.\n\n    Args:\n        http_code: HTTP status code\n        code: Business status code (defaults to http_code if not provided)\n        data: Response payload\n        message: Response message\n    \"\"\"\n    if code is None:\n        code = http_code\n\n    response = Response(code=code, data=data, message=message)\n    return JSONResponse(\n        status_code=http_code,\n        content=response.model_dump(mode=\"json\"),\n    )\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_ok","title":"<code>response_ok(code=None, data=None, message='Success')</code>","text":"<p>Create a successful response (200 OK)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_ok(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Success\",\n) -&gt; JSONResponse:\n    \"\"\"Create a successful response (200 OK)\"\"\"\n    return create_response(status.HTTP_200_OK, code=code if code is not None else 0, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_created","title":"<code>response_created(code=None, data=None, message='Created')</code>","text":"<p>Create a resource created response (201 Created)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_created(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Created\",\n) -&gt; JSONResponse:\n    \"\"\"Create a resource created response (201 Created)\"\"\"\n    return create_response(status.HTTP_201_CREATED, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_bad_request","title":"<code>response_bad_request(code=None, data=None, message='Bad Request')</code>","text":"<p>Create a bad request error response (400 Bad Request)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_bad_request(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Bad Request\",\n) -&gt; JSONResponse:\n    \"\"\"Create a bad request error response (400 Bad Request)\"\"\"\n    return create_response(status.HTTP_400_BAD_REQUEST, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_unauthorized","title":"<code>response_unauthorized(code=None, data=None, message='Unauthorized')</code>","text":"<p>Create an unauthorized response (401 Unauthorized)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_unauthorized(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Unauthorized\",\n) -&gt; JSONResponse:\n    \"\"\"Create an unauthorized response (401 Unauthorized)\"\"\"\n    return create_response(status.HTTP_401_UNAUTHORIZED, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_forbidden","title":"<code>response_forbidden(code=None, data=None, message='Forbidden')</code>","text":"<p>Create a forbidden response (403 Forbidden)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_forbidden(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Forbidden\",\n) -&gt; JSONResponse:\n    \"\"\"Create a forbidden response (403 Forbidden)\"\"\"\n    return create_response(status.HTTP_403_FORBIDDEN, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_not_found","title":"<code>response_not_found(code=None, data=None, message='Not Found')</code>","text":"<p>Create a not found response (404 Not Found)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_not_found(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Not Found\",\n) -&gt; JSONResponse:\n    \"\"\"Create a not found response (404 Not Found)\"\"\"\n    return create_response(status.HTTP_404_NOT_FOUND, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_conflict","title":"<code>response_conflict(code=None, data=None, message='Conflict')</code>","text":"<p>Create a conflict response (409 Conflict)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_conflict(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Conflict\",\n) -&gt; JSONResponse:\n    \"\"\"Create a conflict response (409 Conflict)\"\"\"\n    return create_response(status.HTTP_409_CONFLICT, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_unprocessable_entity","title":"<code>response_unprocessable_entity(code=None, data=None, message='Unprocessable Entity')</code>","text":"<p>Create an unprocessable entity response (422 Unprocessable Entity)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_unprocessable_entity(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Unprocessable Entity\",\n) -&gt; JSONResponse:\n    \"\"\"Create an unprocessable entity response (422 Unprocessable Entity)\"\"\"\n    return create_response(status.HTTP_422_UNPROCESSABLE_ENTITY, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_server_error","title":"<code>response_server_error(code=None, data=None, message='Internal Server Error')</code>","text":"<p>Create a server error response (500 Internal Server Error)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_server_error(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Internal Server Error\",\n) -&gt; JSONResponse:\n    \"\"\"Create a server error response (500 Internal Server Error)\"\"\"\n    return create_response(status.HTTP_500_INTERNAL_SERVER_ERROR, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/schemas/","title":"Data Schemas (DTOs)","text":"<p>ZodiacCore provides a set of base Pydantic models and types to standardize Data Transfer Objects (DTOs). These mirror our database models to ensure end-to-end consistency.</p>"},{"location":"api/schemas/#1-core-models","title":"1. Core Models","text":""},{"location":"api/schemas/#coremodel","title":"CoreModel","text":"<p>The <code>CoreModel</code> is the recommended base class for all your Pydantic models. It comes pre-configured with: - <code>from_attributes=True</code>: Allows easy conversion from ORM objects (like SQLModel or SQLAlchemy) using <code>Model.model_validate(orm_obj)</code>.</p> <pre><code>from zodiac_core import CoreModel\n\nclass UserSchema(CoreModel):\n    username: str\n    email: str\n</code></pre>"},{"location":"api/schemas/#2-standard-schema-mixins","title":"2. Standard Schema Mixins","text":"<p>We provide several mixins to match the <code>IntIDModel</code> and <code>UUIDModel</code> found in the database layer.</p> Schema Primary Key Timestamps <code>IntIDSchema</code> <code>id: int</code> <code>created_at</code>, <code>updated_at</code> <code>UUIDSchema</code> <code>id: UUID</code> <code>created_at</code>, <code>updated_at</code>"},{"location":"api/schemas/#example-usage","title":"Example Usage","text":"<pre><code>from zodiac_core import IntIDSchema\n\nclass ProductRead(IntIDSchema):\n    name: str\n    price: float\n</code></pre>"},{"location":"api/schemas/#3-utc-datetime-utility","title":"3. UTC Datetime Utility","text":"<p>Handling timezones correctly is notoriously difficult. ZodiacCore includes a <code>UtcDatetime</code> type that automatically converts incoming datetime objects to UTC and ensures they are timezone-aware.</p> <pre><code>from zodiac_core import UtcDatetime\nfrom pydantic import BaseModel\n\nclass Event(BaseModel):\n    # Any incoming datetime will be converted to aware-UTC\n    happened_at: UtcDatetime\n</code></pre>"},{"location":"api/schemas/#4-api-reference","title":"4. API Reference","text":""},{"location":"api/schemas/#base-schemas","title":"Base Schemas","text":""},{"location":"api/schemas/#zodiac_core.schemas.UtcDatetime","title":"<code>UtcDatetime = Annotated[datetime, BeforeValidator(ensure_utc)]</code>  <code>module-attribute</code>","text":""},{"location":"api/schemas/#zodiac_core.schemas.CoreModel","title":"<code>CoreModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base Pydantic model for all Zodiac schemas (DTOs).</p> <p>Features: - Standard snake_case fields - From attributes enabled (ORM mode)</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class CoreModel(BaseModel):\n    \"\"\"\n    Base Pydantic model for all Zodiac schemas (DTOs).\n\n    Features:\n    - Standard snake_case fields\n    - From attributes enabled (ORM mode)\n    \"\"\"\n\n    model_config = ConfigDict(\n        from_attributes=True,\n    )\n</code></pre>"},{"location":"api/schemas/#zodiac_core.schemas.IntIDSchema","title":"<code>IntIDSchema</code>","text":"<p>               Bases: <code>CoreModel</code>, <code>IntIDSchemaMixin</code>, <code>DateTimeSchemaMixin</code></p> <p>Base schema for models with an Integer ID and Timestamps. Includes: Core Config + ID + CreatedAt + UpdatedAt.</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class IntIDSchema(CoreModel, IntIDSchemaMixin, DateTimeSchemaMixin):\n    \"\"\"\n    Base schema for models with an Integer ID and Timestamps.\n    Includes: Core Config + ID + CreatedAt + UpdatedAt.\n    \"\"\"\n</code></pre>"},{"location":"api/schemas/#zodiac_core.schemas.UUIDSchema","title":"<code>UUIDSchema</code>","text":"<p>               Bases: <code>CoreModel</code>, <code>UUIDSchemaMixin</code>, <code>DateTimeSchemaMixin</code></p> <p>Base schema for models with a UUID and Timestamps. Includes: Core Config + ID + CreatedAt + UpdatedAt.</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class UUIDSchema(CoreModel, UUIDSchemaMixin, DateTimeSchemaMixin):\n    \"\"\"\n    Base schema for models with a UUID and Timestamps.\n    Includes: Core Config + ID + CreatedAt + UpdatedAt.\n    \"\"\"\n</code></pre>"},{"location":"api/schemas/#zodiac_core.schemas.IntIDSchemaMixin","title":"<code>IntIDSchemaMixin</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include an integer ID.</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class IntIDSchemaMixin(BaseModel):\n    \"\"\"Mixin for models that include an integer ID.\"\"\"\n\n    id: int = Field(\n        ...,\n        description=\"The unique integer identifier.\",\n    )\n</code></pre>"},{"location":"api/schemas/#zodiac_core.schemas.UUIDSchemaMixin","title":"<code>UUIDSchemaMixin</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a UUID.</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class UUIDSchemaMixin(BaseModel):\n    \"\"\"Mixin for models that include a UUID.\"\"\"\n\n    id: UUID = Field(\n        ...,\n        description=\"The unique UUID identifier.\",\n    )\n</code></pre>"},{"location":"api/schemas/#zodiac_core.schemas.DateTimeSchemaMixin","title":"<code>DateTimeSchemaMixin</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include standard timestamps.</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class DateTimeSchemaMixin(BaseModel):\n    \"\"\"Mixin for models that include standard timestamps.\"\"\"\n\n    created_at: UtcDatetime = Field(\n        ...,\n        description=\"The UTC timestamp when the record was created.\",\n    )\n    updated_at: UtcDatetime = Field(\n        ...,\n        description=\"The UTC timestamp when the record was last updated.\",\n    )\n</code></pre>"},{"location":"user-guide/getting-started/","title":"Basic Usage","text":"<p>This guide will walk you through building a complete, production-ready FastAPI application using <code>ZodiacCore</code> in 5 minutes.</p>"},{"location":"user-guide/getting-started/#1-project-initialization","title":"1. Project Initialization","text":"<p>Create a file named <code>main.py</code>. This will be the entry point of your application.</p> <p>First, we setup the core components: Logging and Middleware.</p> <pre><code>from fastapi import FastAPI\nfrom zodiac_core.routing import APIRouter\nfrom zodiac_core.logging import setup_loguru\nfrom zodiac_core.middleware import register_middleware\nfrom zodiac_core.exception_handlers import register_exception_handlers\n\n# 1. Initialize Logging (JSON format for production, trace_id injection)\nsetup_loguru(level=\"INFO\", json_format=True, service_name=\"my-service\")\n\napp = FastAPI(title=\"Zodiac Demo App\")\nrouter = APIRouter()\n\n# 2. Register Middleware (Trace ID, Access Logs)\nregister_middleware(app)\n\n# 3. Register Global Exception Handlers (Standardized 4xx/5xx responses)\nregister_exception_handlers(app)\n\n# 4. Include Router (Must be done after adding routes, but shown here for setup)\n# app.include_router(router)\n</code></pre>"},{"location":"user-guide/getting-started/#2-standard-response-wrapper","title":"2. Standard Response Wrapper","text":"<p>When you use Zodiac's <code>APIRouter</code>, all successful responses are automatically wrapped in a standard structure. You don't need to manually return a <code>Response</code> object; just return your data (dict, Pydantic model, or list).</p> <pre><code>@router.get(\"/profile\")\nasync def get_profile():\n    return {\"username\": \"zodiac_user\", \"email\": \"user@example.com\"}\n</code></pre> <p>The resulting JSON will be: <pre><code>{\n  \"code\": 0,\n  \"message\": \"Success\",\n  \"data\": {\n    \"username\": \"zodiac_user\",\n    \"email\": \"user@example.com\"\n  }\n}\n</code></pre></p> <p>This ensures that your frontend developers always receive a predictable response format, whether it's a success or an error.</p>"},{"location":"user-guide/getting-started/#3-handling-exceptions","title":"3. Handling Exceptions","text":"<p>Forget <code>try-except</code> blocks everywhere. Just raise <code>ZodiacException</code> subclasses.</p> <pre><code>from zodiac_core.exceptions import NotFoundException, BadRequestException\n\n@router.get(\"/items/{item_id}\")\nasync def read_item(item_id: int):\n    if item_id == 0:\n        # Automatically returns 400 Bad Request with standard error format\n        raise BadRequestException(message=\"Item ID cannot be zero\")\n\n    if item_id &gt; 100:\n        # Automatically returns 404 Not Found\n        raise NotFoundException(message=f\"Item {item_id} not found\")\n\n    return {\"item_id\": item_id}\n</code></pre> <p>Standard Error Format</p> <p>The response will look like: <pre><code>{\n  \"code\": 404,\n  \"message\": \"Item 101 not found\",\n  \"data\": null\n}\n</code></pre></p>"},{"location":"user-guide/getting-started/#4-implementing-pagination","title":"4. Implementing Pagination","text":"<p>Use <code>PageParams</code> for input and <code>PagedResponse</code> for output. No more manual math.</p> <pre><code>from typing import Annotated\nfrom fastapi import Query\nfrom pydantic import BaseModel\nfrom zodiac_core.pagination import PageParams, PagedResponse\n\n# Define a simple schema\nclass UserSchema(BaseModel):\n    id: int\n    name: str\n\n# Mock database\nUSERS_DB = [UserSchema(id=i, name=f\"User {i}\") for i in range(1, 100)]\n\n@router.get(\"/users\", response_model=PagedResponse[UserSchema])\nasync def list_users(\n    page_params: Annotated[PageParams, Query()]\n):\n    \"\"\"\n    Standard pagination endpoint.\n    Query params: ?page=1&amp;size=20\n    \"\"\"\n    # Calculate offset\n    skip = (page_params.page - 1) * page_params.size\n    limit = page_params.size\n\n    # Slice data (simulate DB query)\n    data = USERS_DB[skip : skip + limit]\n    total = len(USERS_DB)\n\n    # Return standard paginated response\n    return PagedResponse.create(\n        items=data,\n        total=total,\n        params=page_params\n    )\n</code></pre>"},{"location":"user-guide/getting-started/#5-database-integration-sqlmodel","title":"5. Database Integration (SQLModel)","text":"<p>Use <code>BaseSQLRepository</code> for a clean, async repository pattern with SQLModel.</p> <p>First, define your model (using SQLModel or pure SQLAlchemy):</p> <pre><code>from sqlmodel import Field\nfrom zodiac_core.db.sql import IntIDModel\n\n# Inherit from IntIDModel to get 'id', 'created_at', and 'updated_at' automatically\nclass Hero(IntIDModel, table=True):\n    name: str\n    secret_name: str\n</code></pre> <p>Then, create a repository:</p> <pre><code>from typing import List, Optional\nfrom sqlalchemy import select\nfrom zodiac_core.db.repository import BaseSQLRepository\n\nclass HeroRepository(BaseSQLRepository):\n\n    async def create(self, hero: Hero) -&gt; Hero:\n        # Use self.session() context manager\n        async with self.session() as session:\n            session.add(hero)\n            await session.commit()\n            await session.refresh(hero)\n            return hero\n\n    async def get_all(self) -&gt; List[Hero]:\n        async with self.session() as session:\n            stmt = select(Hero)\n            result = await session.execute(stmt)\n            return result.scalars().all()\n</code></pre> <p>Finally, use it in your route. Define a lifespan for DB lifecycle (FastAPI recommends this over the deprecated <code>on_event(\"startup\")</code> / <code>on_event(\"shutdown\")</code>). In Step 1, use <code>app = FastAPI(title=\"Zodiac Demo App\", lifespan=lifespan)</code> instead of <code>app = FastAPI(...)</code>.</p> <pre><code>from contextlib import asynccontextmanager\nfrom zodiac_core.db.session import db\n\n@asynccontextmanager\nasync def lifespan(app):\n    db.setup(\"sqlite+aiosqlite:///database.db\")\n    await db.create_all()\n    yield\n    await db.shutdown()\n\n# In Step 1, create app with: app = FastAPI(title=\"Zodiac Demo App\", lifespan=lifespan)\n\n@router.post(\"/heroes\")\nasync def create_hero(hero: Hero):\n    repo = HeroRepository()\n    return await repo.create(hero)\n\n# Finally, include the router in the app\napp.include_router(router)\n</code></pre>"},{"location":"user-guide/getting-started/#summary","title":"Summary","text":"<p>You now have a fully functional application with:</p> <ul> <li>\u2705 Structured Logging</li> <li>\u2705 Trace ID Propagation</li> <li>\u2705 Standard Error Handling</li> <li>\u2705 Pagination Support</li> <li>\u2705 Async Database Sessions</li> </ul> <p>Run it with: <pre><code>uvicorn main:app --reload\n</code></pre></p>"},{"location":"user-guide/installation/","title":"Installation Guide","text":"<p>ZodiacCore is designed to be modular. You can install only what you need.</p>"},{"location":"user-guide/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: 3.12 or higher</li> <li>Package Manager: <code>pip</code> (standard) or <code>uv</code> (recommended for performance)</li> </ul>"},{"location":"user-guide/installation/#1-basic-installation","title":"1. Basic Installation","text":"<p>For a minimal setup (Core utilities, Logging, Exception Handling, Middleware, ...):</p> <pre><code>uv add zodiac-core\n</code></pre>"},{"location":"user-guide/installation/#2-installing-with-database-support","title":"2. Installing with Database Support","text":"<p>ZodiacCore separates database dependencies to keep the core lightweight. You can choose to install a single database backend or multiple backends simultaneously.</p>"},{"location":"user-guide/installation/#sql-support-sqlalchemy-sqlmodel","title":"SQL Support (SQLAlchemy + SQLModel)","text":"<p>To use SQL databases, you must install the <code>sql</code> extra along with the appropriate async database driver for your specific database.</p> <pre><code># 1. Install SQL support\nuv add \"zodiac-core[sql]\"\n\n# 2. Install preferred async driver (Examples)\nuv add asyncpg       # For PostgreSQL\nuv add aiosqlite     # For SQLite\nuv add aiomysql      # For MySQL\n</code></pre>"},{"location":"user-guide/installation/#mongodb-support-motor","title":"MongoDB Support (Motor)","text":"<p>Installs the <code>motor</code> extra so you can use the async MongoDB driver in your app. The library does not yet provide built-in MongoDB session or repository helpers; this extra is for dependency convenience.</p> <pre><code>uv add \"zodiac-core[mongo]\"\n</code></pre>"},{"location":"user-guide/installation/#multiple-databases","title":"Multiple Databases","text":"<p>To install support for both SQL and MongoDB:</p> <pre><code>uv add \"zodiac-core[sql,mongo]\"\n</code></pre>"},{"location":"user-guide/installation/#3-installing-everything-for-development","title":"3. Installing Everything (For Development)","text":"<p>If you are setting up a development environment or need all features:</p> <pre><code>uv sync --all-extras --all-groups\n</code></pre>"},{"location":"user-guide/installation/#4-verifying-installation","title":"4. Verifying Installation","text":"<p>You can verify the installed version and importability:</p> <pre><code>python -c \"import zodiac_core; print(zodiac_core.__version__)\"\n</code></pre>"}]}