{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to ZodiacCore-Py","text":"<p>The opinionated, async-first core library for modern Python web services.</p> <ul> <li>Source: GitHub \u2014 TTWShell/ZodiacCore-Py</li> <li>Package: PyPI \u2014 zodiac-core</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<ul> <li>Installation \u2014 Install and optional extras (SQL, Mongo).</li> <li>Getting started \u2014 Basic usage and examples.</li> <li>Architecture Guide \u2014 Layered architecture (3-tier recommended, extensible to 4-tier) with dependency injection.</li> <li>CLI Documentation \u2014 Scaffold projects with <code>zodiac new</code>.</li> <li>API Reference \u2014 Configuration, context, database, exceptions, logging, middleware, pagination, routing, schemas.</li> </ul>"},{"location":"#project-links","title":"Project links","text":"<ul> <li>Contributing \u2014 How to contribute.</li> <li>License \u2014 MIT License.</li> </ul>"},{"location":"api/config/","title":"Configuration Management","text":"<p>ZodiacCore provides a robust utility for managing application settings using <code>.ini</code> files. It is designed to follow the \"Base + Override\" pattern, making it ideal for multi-environment deployments (Development, Testing, Production).</p>"},{"location":"api/config/#1-core-concepts","title":"1. Core Concepts","text":""},{"location":"api/config/#environment-based-loading","title":"Environment-Based Loading","text":"<p>The configuration system automatically detects your current environment (via environment variables) and loads files in a specific order:</p> <ol> <li>Base Config: Files like <code>app.ini</code>. These are loaded first.</li> <li>Environment Config: Files like <code>app.production.ini</code>. These are loaded second, overriding any matching keys from the base config.</li> </ol>"},{"location":"api/config/#dot-notation-access","title":"Dot-Notation Access","text":"<p>Instead of using dictionary keys (e.g., <code>config['db']['host']</code>), ZodiacCore can convert your settings into a <code>SimpleNamespace</code>, allowing for cleaner dot-notation access (e.g., <code>config.db.host</code>).</p>"},{"location":"api/config/#2-setting-up-your-config-folder","title":"2. Setting Up Your Config Folder","text":"<p>A typical production-ready configuration folder structure:</p> <pre><code>config/\n\u251c\u2500\u2500 app.ini             # Default settings (all environments)\n\u251c\u2500\u2500 app.develop.ini     # Local development overrides\n\u2514\u2500\u2500 app.production.ini  # Production secrets/tuning\n</code></pre>"},{"location":"api/config/#loading-the-config","title":"Loading the Config","text":"<p>You can use <code>ConfigManagement</code> to find the correct files and then load them using your preferred library (like <code>configparser</code> or <code>dependency-injector</code>).</p> <pre><code>from pathlib import Path\nfrom zodiac_core import ConfigManagement\n\n# 1. Get the list of files in correct loading order\nconfig_dir = Path(__file__).parent / \"config\"\nconfig_files = ConfigManagement.get_config_files(\n    search_paths=[config_dir],\n    env_var=\"APPLICATION_ENVIRONMENT\",  # Default: APPLICATION_ENVIRONMENT\n    default_env=\"develop\"                # Fallback if env_var is missing\n)\n\n# Returns: ['.../config/app.ini', '.../config/app.develop.ini']\n</code></pre>"},{"location":"api/config/#3-configuration-objects","title":"3. Configuration Objects","text":"<p>ZodiacCore provides two ways to access your configuration data using <code>ConfigManagement.provide_config</code>:</p>"},{"location":"api/config/#mode-a-simplenamespace-quick-access","title":"Mode A: SimpleNamespace (Quick Access)","text":"<p>This mode is useful for rapid prototyping. It converts the dictionary into a <code>SimpleNamespace</code>, allowing for dot-notation access but without type hints or validation.</p> <pre><code>raw_data = {\"db\": {\"host\": \"localhost\", \"port\": 5432}}\nconfig = ConfigManagement.provide_config(raw_data)\n\nprint(config.db.host)  # 'localhost'\n</code></pre>"},{"location":"api/config/#mode-b-pydantic-model-recommended","title":"Mode B: Pydantic Model (Recommended)","text":"<p>For production applications, it is highly recommended to use a Pydantic model. This provides:</p> <ol> <li>Type Safety: Full IDE autocompletion and type checking.</li> <li>Validation: Runtime checks to ensure your configuration is valid.</li> <li>Defaults: Automatically fill in missing values defined in your schema.</li> </ol> <pre><code>from pydantic import BaseModel\nfrom zodiac_core import ConfigManagement\n\nclass DbConfig(BaseModel):\n    host: str\n    port: int = 5432\n\nclass AppConfig(BaseModel):\n    db: DbConfig\n\nraw_data = {\"db\": {\"host\": \"localhost\"}}\n# Pass the model class as the second argument\nconfig = ConfigManagement.provide_config(raw_data, AppConfig)\n\nprint(config.db.host)  # 'localhost' (with IDE autocomplete!)\nprint(config.db.port)  # 5432 (default value applied)\n</code></pre>"},{"location":"api/config/#4-api-reference","title":"4. API Reference","text":""},{"location":"api/config/#environment-enum","title":"Environment Enum","text":""},{"location":"api/config/#zodiac_core.config.Environment","title":"<code>zodiac_core.config.Environment</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Supported application environments.</p> Source code in <code>zodiac_core/config.py</code> <pre><code>class Environment(str, Enum):\n    \"\"\"\n    Supported application environments.\n    \"\"\"\n\n    DEVELOP = \"develop\"  # Local development\n    TESTING = \"testing\"  # Testing environment\n    STAGING = \"staging\"  # Staging environment (reserved)\n    PRODUCTION = \"production\"  # Production environment\n</code></pre>"},{"location":"api/config/#configuration-management_1","title":"Configuration Management","text":""},{"location":"api/config/#zodiac_core.config.ConfigManagement","title":"<code>zodiac_core.config.ConfigManagement</code>","text":"<p>Configuration management utility for scanning, loading, and converting configuration files.</p> <p>This utility is designed to work well with configuration loading patterns where subsequent files override previous ones (e.g., standard <code>configparser</code> or <code>dependency-injector</code>).</p> <p>See: https://python-dependency-injector.ets-labs.org/providers/configuration.html</p> Source code in <code>zodiac_core/config.py</code> <pre><code>class ConfigManagement:\n    \"\"\"\n    Configuration management utility for scanning, loading, and converting configuration files.\n\n    This utility is designed to work well with configuration loading patterns where\n    subsequent files override previous ones (e.g., standard `configparser` or\n    `dependency-injector`).\n\n    See: https://python-dependency-injector.ets-labs.org/providers/configuration.html\n    \"\"\"\n\n    @staticmethod\n    def get_config_files(\n        search_paths: List[Union[str, Path]],\n        env_var: str = \"APPLICATION_ENVIRONMENT\",\n        default_env: str = \"production\",\n    ) -&gt; List[str]:\n        \"\"\"\n        Scans specified directories for configuration files and returns them in loading order.\n\n        The scanning strategy follows these rules:\n        1. Base Config: Files with at most one dot (e.g., 'app.ini'). Loaded first.\n        2. Env Config: Files matching '{name}.{env}.ini' (e.g., 'app.develop.ini'). Loaded second.\n\n        The returned order (Base -&gt; Env) ensures that environment-specific settings\n        override base settings when loaded by configuration providers.\n\n        Files not matching the current environment but belonging to a known Environment enum\n        are silently skipped. Files with unknown environment suffixes are logged as debug.\n\n        Args:\n            search_paths: List of directory paths to search. **REQUIRED**.\n            env_var: Environment variable name to determine current environment.\n            default_env: Fallback environment if env_var is not set.\n\n        Returns:\n            A list of absolute paths to configuration files, sorted by priority (Base -&gt; Env).\n\n        Example:\n            ```python\n            from pathlib import Path\n            from zodiac_core import ConfigManagement\n\n            # Resolve config path relative to your main application file\n            config_dir = Path(__file__).parent / \"config\"\n            files = ConfigManagement.get_config_files(search_paths=[config_dir])\n            ```\n        \"\"\"\n\n        target_env = os.environ.get(env_var, default_env).lower()\n        base_files = []\n        env_files = []\n\n        # Normalize paths\n        abs_paths = [Path(p).resolve() for p in search_paths if p]\n\n        # Valid environments set for quick lookup\n        valid_envs = {e.value for e in Environment}\n\n        for config_dir in abs_paths:\n            if not config_dir.exists():\n                continue\n\n            # Get all .ini files and sort them to ensure deterministic order\n            ini_files = sorted(glob.glob(str(config_dir / \"*.ini\")))\n\n            for file_path in ini_files:\n                filename = os.path.basename(file_path)\n\n                if ConfigManagement.__is_base_config_file(filename):\n                    base_files.append(str(file_path))\n                    continue\n\n                # Rule 2: Env Config ({name}.{env}.ini)\n                candidate_env = ConfigManagement.__get_configuration_env(filename)\n\n                if candidate_env == target_env:\n                    env_files.append(str(file_path))\n                elif candidate_env in valid_envs:\n                    # Valid environment file, but not for current environment. Skip silently.\n                    pass\n                else:\n                    # Unknown environment or weird format. Log it.\n                    logger.debug(f\"Ignored config file (unknown env/format): {file_path}\")\n\n        return base_files + env_files\n\n    @overload\n    @staticmethod\n    def provide_config(config: dict) -&gt; SimpleNamespace: ...\n\n    @overload\n    @staticmethod\n    def provide_config(config: dict, model: Type[T]) -&gt; T: ...\n\n    @staticmethod\n    def provide_config(config: dict = None, model: Type[T] = None) -&gt; Union[SimpleNamespace, T]:\n        \"\"\"\n        Converts a configuration dictionary into a structured object.\n\n        Supports two modes:\n        1. **SimpleNamespace mode** (default): Returns a SimpleNamespace for dot notation access.\n        2. **Pydantic model mode**: Pass a Pydantic model class to get type-safe, validated config.\n\n        Args:\n            config: The configuration dictionary to convert.\n            model: Optional Pydantic model class. If provided, returns an instance of this model.\n\n        Returns:\n            SimpleNamespace if no model provided, otherwise an instance of the model.\n\n        Example:\n            ```python\n            # Mode 1: SimpleNamespace (no type hints, but convenient)\n            config = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}})\n            print(config.db.host)  # \"localhost\"\n\n            # Mode 2: Pydantic model (full type hints and validation)\n            from pydantic import BaseModel\n\n            class DbConfig(BaseModel):\n                host: str\n                port: int = 5432\n\n            class AppConfig(BaseModel):\n                db: DbConfig\n\n            config = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}}, AppConfig)\n            print(config.db.host)  # IDE autocomplete works!\n            print(config.db.port)  # 5432 (default value)\n            ```\n        \"\"\"\n        if config is None:\n            config = {}\n\n        # Pydantic model mode: delegate to Pydantic for validation and type coercion\n        if model is not None:\n            return model(**config)\n\n        # SimpleNamespace mode: recursive conversion\n        def _convert(value):\n            if isinstance(value, dict):\n                return SimpleNamespace(**{k: _convert(v) for k, v in value.items()})\n            elif isinstance(value, list):\n                return [_convert(item) for item in value]\n            return value\n\n        return _convert(config)\n\n    @staticmethod\n    def __is_base_config_file(filename: str) -&gt; bool:\n        \"\"\"\n        Checks if a filename represents a base configuration file.\n\n        Base files are identified by having one dot in their name.\n        \"\"\"\n        return filename.count(\".\") == 1\n\n    @staticmethod\n    def __get_configuration_env(filename: str) -&gt; str:\n        \"\"\"\n        Extracts the environment name segment from a configuration filename.\n\n        Expected format: {name}.{env}.ini\n        \"\"\"\n        parts = filename.split(\".\")\n        # Caller ensure we have at least 2 dots (split into &gt;= 3 parts)\n        # by checking __is_base_config_file first.\n        return parts[-2].lower()\n</code></pre>"},{"location":"api/config/#zodiac_core.config.ConfigManagement.get_config_files","title":"<code>get_config_files(search_paths, env_var='APPLICATION_ENVIRONMENT', default_env='production')</code>  <code>staticmethod</code>","text":"<p>Scans specified directories for configuration files and returns them in loading order.</p> <p>The scanning strategy follows these rules: 1. Base Config: Files with at most one dot (e.g., 'app.ini'). Loaded first. 2. Env Config: Files matching '{name}.{env}.ini' (e.g., 'app.develop.ini'). Loaded second.</p> <p>The returned order (Base -&gt; Env) ensures that environment-specific settings override base settings when loaded by configuration providers.</p> <p>Files not matching the current environment but belonging to a known Environment enum are silently skipped. Files with unknown environment suffixes are logged as debug.</p> <p>Parameters:</p> Name Type Description Default <code>search_paths</code> <code>List[Union[str, Path]]</code> <p>List of directory paths to search. REQUIRED.</p> required <code>env_var</code> <code>str</code> <p>Environment variable name to determine current environment.</p> <code>'APPLICATION_ENVIRONMENT'</code> <code>default_env</code> <code>str</code> <p>Fallback environment if env_var is not set.</p> <code>'production'</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>A list of absolute paths to configuration files, sorted by priority (Base -&gt; Env).</p> Example <pre><code>from pathlib import Path\nfrom zodiac_core import ConfigManagement\n\n# Resolve config path relative to your main application file\nconfig_dir = Path(__file__).parent / \"config\"\nfiles = ConfigManagement.get_config_files(search_paths=[config_dir])\n</code></pre> Source code in <code>zodiac_core/config.py</code> <pre><code>@staticmethod\ndef get_config_files(\n    search_paths: List[Union[str, Path]],\n    env_var: str = \"APPLICATION_ENVIRONMENT\",\n    default_env: str = \"production\",\n) -&gt; List[str]:\n    \"\"\"\n    Scans specified directories for configuration files and returns them in loading order.\n\n    The scanning strategy follows these rules:\n    1. Base Config: Files with at most one dot (e.g., 'app.ini'). Loaded first.\n    2. Env Config: Files matching '{name}.{env}.ini' (e.g., 'app.develop.ini'). Loaded second.\n\n    The returned order (Base -&gt; Env) ensures that environment-specific settings\n    override base settings when loaded by configuration providers.\n\n    Files not matching the current environment but belonging to a known Environment enum\n    are silently skipped. Files with unknown environment suffixes are logged as debug.\n\n    Args:\n        search_paths: List of directory paths to search. **REQUIRED**.\n        env_var: Environment variable name to determine current environment.\n        default_env: Fallback environment if env_var is not set.\n\n    Returns:\n        A list of absolute paths to configuration files, sorted by priority (Base -&gt; Env).\n\n    Example:\n        ```python\n        from pathlib import Path\n        from zodiac_core import ConfigManagement\n\n        # Resolve config path relative to your main application file\n        config_dir = Path(__file__).parent / \"config\"\n        files = ConfigManagement.get_config_files(search_paths=[config_dir])\n        ```\n    \"\"\"\n\n    target_env = os.environ.get(env_var, default_env).lower()\n    base_files = []\n    env_files = []\n\n    # Normalize paths\n    abs_paths = [Path(p).resolve() for p in search_paths if p]\n\n    # Valid environments set for quick lookup\n    valid_envs = {e.value for e in Environment}\n\n    for config_dir in abs_paths:\n        if not config_dir.exists():\n            continue\n\n        # Get all .ini files and sort them to ensure deterministic order\n        ini_files = sorted(glob.glob(str(config_dir / \"*.ini\")))\n\n        for file_path in ini_files:\n            filename = os.path.basename(file_path)\n\n            if ConfigManagement.__is_base_config_file(filename):\n                base_files.append(str(file_path))\n                continue\n\n            # Rule 2: Env Config ({name}.{env}.ini)\n            candidate_env = ConfigManagement.__get_configuration_env(filename)\n\n            if candidate_env == target_env:\n                env_files.append(str(file_path))\n            elif candidate_env in valid_envs:\n                # Valid environment file, but not for current environment. Skip silently.\n                pass\n            else:\n                # Unknown environment or weird format. Log it.\n                logger.debug(f\"Ignored config file (unknown env/format): {file_path}\")\n\n    return base_files + env_files\n</code></pre>"},{"location":"api/config/#zodiac_core.config.ConfigManagement.provide_config","title":"<code>provide_config(config=None, model=None)</code>  <code>staticmethod</code>","text":"<pre><code>provide_config(config: dict) -&gt; SimpleNamespace\n</code></pre><pre><code>provide_config(config: dict, model: Type[T]) -&gt; T\n</code></pre> <p>Converts a configuration dictionary into a structured object.</p> <p>Supports two modes: 1. SimpleNamespace mode (default): Returns a SimpleNamespace for dot notation access. 2. Pydantic model mode: Pass a Pydantic model class to get type-safe, validated config.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>The configuration dictionary to convert.</p> <code>None</code> <code>model</code> <code>Type[T]</code> <p>Optional Pydantic model class. If provided, returns an instance of this model.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[SimpleNamespace, T]</code> <p>SimpleNamespace if no model provided, otherwise an instance of the model.</p> Example <pre><code># Mode 1: SimpleNamespace (no type hints, but convenient)\nconfig = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}})\nprint(config.db.host)  # \"localhost\"\n\n# Mode 2: Pydantic model (full type hints and validation)\nfrom pydantic import BaseModel\n\nclass DbConfig(BaseModel):\n    host: str\n    port: int = 5432\n\nclass AppConfig(BaseModel):\n    db: DbConfig\n\nconfig = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}}, AppConfig)\nprint(config.db.host)  # IDE autocomplete works!\nprint(config.db.port)  # 5432 (default value)\n</code></pre> Source code in <code>zodiac_core/config.py</code> <pre><code>@staticmethod\ndef provide_config(config: dict = None, model: Type[T] = None) -&gt; Union[SimpleNamespace, T]:\n    \"\"\"\n    Converts a configuration dictionary into a structured object.\n\n    Supports two modes:\n    1. **SimpleNamespace mode** (default): Returns a SimpleNamespace for dot notation access.\n    2. **Pydantic model mode**: Pass a Pydantic model class to get type-safe, validated config.\n\n    Args:\n        config: The configuration dictionary to convert.\n        model: Optional Pydantic model class. If provided, returns an instance of this model.\n\n    Returns:\n        SimpleNamespace if no model provided, otherwise an instance of the model.\n\n    Example:\n        ```python\n        # Mode 1: SimpleNamespace (no type hints, but convenient)\n        config = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}})\n        print(config.db.host)  # \"localhost\"\n\n        # Mode 2: Pydantic model (full type hints and validation)\n        from pydantic import BaseModel\n\n        class DbConfig(BaseModel):\n            host: str\n            port: int = 5432\n\n        class AppConfig(BaseModel):\n            db: DbConfig\n\n        config = ConfigManagement.provide_config({\"db\": {\"host\": \"localhost\"}}, AppConfig)\n        print(config.db.host)  # IDE autocomplete works!\n        print(config.db.port)  # 5432 (default value)\n        ```\n    \"\"\"\n    if config is None:\n        config = {}\n\n    # Pydantic model mode: delegate to Pydantic for validation and type coercion\n    if model is not None:\n        return model(**config)\n\n    # SimpleNamespace mode: recursive conversion\n    def _convert(value):\n        if isinstance(value, dict):\n            return SimpleNamespace(**{k: _convert(v) for k, v in value.items()})\n        elif isinstance(value, list):\n            return [_convert(item) for item in value]\n        return value\n\n    return _convert(config)\n</code></pre>"},{"location":"api/context/","title":"Tracing &amp; HTTP Clients","text":"<p>ZodiacCore provides built-in support for Distributed Tracing. It ensures that a single Request ID (Trace ID) flows through your entire ecosystem: from the incoming request, through your logs, and out to downstream microservices via HTTP clients.</p>"},{"location":"api/context/#1-how-it-works","title":"1. How it Works","text":"<ol> <li>Extraction: <code>TraceIDMiddleware</code> catches <code>X-Request-ID</code> from incoming headers (or generates a new one).</li> <li>Storage: The ID is stored in a thread-safe <code>ContextVar</code> (managed by <code>zodiac_core.context</code>).</li> <li>Observation: Logging utilities automatically pick up this ID from the context.</li> <li>Propagation: <code>ZodiacClient</code> automatically injects this ID into outgoing HTTP requests.</li> </ol>"},{"location":"api/context/#2-distributed-tracing-http-clients","title":"2. Distributed Tracing (HTTP Clients)","text":"<p>When calling other services, use <code>ZodiacClient</code> (Async) or <code>ZodiacSyncClient</code> (Sync). They are thin wrappers around <code>httpx</code> that automatically handle Trace ID propagation.</p>"},{"location":"api/context/#async-usage-recommended","title":"Async Usage (Recommended)","text":"<pre><code>from zodiac_core.http import ZodiacClient\n\nasync def call_downstream():\n    async with ZodiacClient(base_url=\"https://api.internal.service\") as client:\n        # X-Request-ID is automatically added to headers\n        response = await client.get(\"/data\")\n        return response.json()\n</code></pre>"},{"location":"api/context/#sync-usage","title":"Sync Usage","text":"<pre><code>from zodiac_core.http import ZodiacSyncClient\n\ndef sync_call():\n    with ZodiacSyncClient() as client:\n        resp = client.get(\"https://google.com\")\n        return resp.status_code\n</code></pre>"},{"location":"api/context/#3-manual-context-access","title":"3. Manual Context Access","text":"<p>In rare cases where you aren't using <code>ZodiacClient</code> (e.g., using <code>aiohttp</code> or <code>requests</code>), you can manually retrieve the current Request ID.</p> <pre><code>from zodiac_core.context import get_request_id\n\nrequest_id = get_request_id()\n# Manually pass it to other systems...\n</code></pre>"},{"location":"api/context/#4-api-reference","title":"4. API Reference","text":""},{"location":"api/context/#http-clients-tracing-enabled","title":"HTTP Clients (Tracing Enabled)","text":""},{"location":"api/context/#zodiac_core.http.ZodiacClient","title":"<code>ZodiacClient</code>","text":"<p>               Bases: <code>AsyncClient</code></p> <p>A wrapper around httpx.AsyncClient that automatically injects the current Trace ID into outgoing requests.</p> Source code in <code>zodiac_core/http.py</code> <pre><code>class ZodiacClient(httpx.AsyncClient):\n    \"\"\"\n    A wrapper around httpx.AsyncClient that automatically injects\n    the current Trace ID into outgoing requests.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        timeout: float = 30.0,\n        event_hooks: Optional[Dict[str, Any]] = None,\n        **kwargs: Any,\n    ):\n        super().__init__(\n            timeout=timeout,\n            event_hooks=_merge_hooks(event_hooks, _inject_trace_id_async_hook),\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/context/#zodiac_core.http.ZodiacSyncClient","title":"<code>ZodiacSyncClient</code>","text":"<p>               Bases: <code>Client</code></p> <p>A wrapper around httpx.Client that automatically injects the current Trace ID into outgoing requests.</p> Source code in <code>zodiac_core/http.py</code> <pre><code>class ZodiacSyncClient(httpx.Client):\n    \"\"\"\n    A wrapper around httpx.Client that automatically injects\n    the current Trace ID into outgoing requests.\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        timeout: float = 30.0,\n        event_hooks: Optional[Dict[str, Any]] = None,\n        **kwargs: Any,\n    ):\n        super().__init__(\n            timeout=timeout,\n            event_hooks=_merge_hooks(event_hooks, _inject_trace_id_hook),\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/context/#context-utilities","title":"Context Utilities","text":""},{"location":"api/context/#zodiac_core.context.get_request_id","title":"<code>get_request_id()</code>","text":"<p>Retrieve the current Request ID from the context.</p> Usage <pre><code>headers = {\"X-Request-ID\": get_request_id()}\nrequests.get(url, headers=headers)\n</code></pre> Source code in <code>zodiac_core/context.py</code> <pre><code>def get_request_id() -&gt; Optional[str]:\n    \"\"\"\n    Retrieve the current Request ID from the context.\n\n    Usage:\n        ```python\n        headers = {\"X-Request-ID\": get_request_id()}\n        requests.get(url, headers=headers)\n        ```\n    \"\"\"\n    return _request_id_ctx_var.get()\n</code></pre>"},{"location":"api/db/","title":"Database Engine &amp; ORM","text":"<p>ZodiacCore provides a high-performance, async-first database abstraction layer built on top of SQLModel and SQLAlchemy 2.0. It simplifies session management, connection pooling, and standardizes model definitions.</p>"},{"location":"api/db/#1-core-concepts","title":"1. Core Concepts","text":""},{"location":"api/db/#the-database-manager","title":"The Database Manager","text":"<p>The <code>DatabaseManager</code> (exposed as the global <code>db</code> instance) is a strict singleton that manages the SQLAlchemy <code>AsyncEngine</code> and <code>async_sessionmaker</code>. It ensures that your application maintains a single connection pool, which is critical for performance and resource management.</p>"},{"location":"api/db/#the-repository-pattern","title":"The Repository Pattern","text":"<p>We encourage the use of the Repository Pattern via <code>BaseSQLRepository</code>. This decouples your business logic from database-specific code, making your application more maintainable and easier to unit test with mocks.</p>"},{"location":"api/db/#2-model-definitions","title":"2. Model Definitions","text":"<p>ZodiacCore provides several mixins and base classes in <code>zodiac_core.db.sql</code> to standardize your database schema.</p>"},{"location":"api/db/#standard-base-models","title":"Standard Base Models","text":"<p>Instead of inheriting from <code>SQLModel</code> directly, we recommend using our pre-configured base models:</p> Base Model Primary Key Timestamps <code>IntIDModel</code> <code>id: int</code> (Auto-increment) <code>created_at</code>, <code>updated_at</code> <code>UUIDModel</code> <code>id: UUID</code> (v4) <code>created_at</code>, <code>updated_at</code>"},{"location":"api/db/#example-using-base-models","title":"Example: Using Base Models","text":"<pre><code>from zodiac_core.db.sql import IntIDModel\nfrom sqlmodel import Field\n\nclass User(IntIDModel, table=True):\n    username: str = Field(unique=True, index=True)\n    email: str\n</code></pre>"},{"location":"api/db/#automatic-timestamps","title":"Automatic Timestamps","text":"<p>Both <code>IntIDModel</code> and <code>UUIDModel</code> include <code>SQLDateTimeMixin</code>, which provides:</p> <ul> <li>created_at: Automatically set on insertion.</li> <li>updated_at: Automatically updated on every save via a SQLAlchemy event listener.</li> </ul>"},{"location":"api/db/#3-configuration-lifecycle","title":"3. Configuration &amp; Lifecycle","text":"<p>You should initialize the database during your application's startup and ensure it shuts down cleanly.</p>"},{"location":"api/db/#fastapi-integration","title":"FastAPI Integration","text":"<p>We recommend using the lifespan context manager (FastAPI 0.93+). The legacy <code>on_event(\"startup\")</code> / <code>on_event(\"shutdown\")</code> are deprecated.</p> <pre><code>from contextlib import asynccontextmanager\nfrom fastapi import FastAPI\nfrom zodiac_core.db.session import db\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    db.setup(\n        \"postgresql+asyncpg://user:pass@localhost/dbname\",\n        pool_size=20,\n        max_overflow=10,\n        echo=False\n    )\n    await db.create_all()  # Optional: create tables if they don't exist\n    yield\n    await db.shutdown()\n\napp = FastAPI(lifespan=lifespan)\n</code></pre>"},{"location":"api/db/#4-working-with-repositories","title":"4. Working with Repositories","text":"<p>Inherit from <code>BaseSQLRepository</code> to create your data access layer.</p> <pre><code>from zodiac_core.db.repository import BaseSQLRepository\nfrom sqlalchemy import select\nfrom .models import User\n\nclass UserRepository(BaseSQLRepository):\n    async def find_by_username(self, username: str) -&gt; User | None:\n        async with self.session() as session:\n            stmt = select(User).where(User.username == username)\n            result = await session.execute(stmt)\n            return result.scalar_one_or_none()\n\n    async def create_user(self, user: User) -&gt; User:\n        async with self.session() as session:\n            session.add(user)\n            await session.commit()\n            await session.refresh(user)\n            return user\n</code></pre>"},{"location":"api/db/#5-multi-database-support","title":"5. Multi-Database Support","text":"<p>ZodiacCore supports multiple database connections simultaneously. This is essential for architectures involving:</p> <ul> <li>Read-Write Splitting: Routing writes to a Master and reads to a Replica.</li> <li>Vertical Partitioning: Storing different modules (e.g., Users, Analytics) in separate databases.</li> </ul>"},{"location":"api/db/#registering-named-databases","title":"Registering Named Databases","text":"<p>You can call <code>db.setup()</code> multiple times with different <code>name</code> arguments.</p> <pre><code># Primary Database (Master)\ndb.setup(\"postgresql+asyncpg://master_db_url\", name=\"default\")\n\n# Read-only Replica\ndb.setup(\"postgresql+asyncpg://replica_db_url\", name=\"read_only\")\n</code></pre>"},{"location":"api/db/#binding-repositories-to-a-database","title":"Binding Repositories to a Database","text":"<p>When creating a repository, specify which database it should use via <code>db_name</code>.</p> <pre><code>class ReadOnlyUserRepository(BaseSQLRepository):\n    def __init__(self):\n        # This repo will always use the 'read_only' engine\n        super().__init__(db_name=\"read_only\")\n\n    async def get_total_users(self) -&gt; int:\n        async with self.session() as session:\n            # Executes on replica\n            ...\n</code></pre>"},{"location":"api/db/#6-api-reference","title":"6. API Reference","text":""},{"location":"api/db/#session-lifecycle","title":"Session &amp; Lifecycle","text":""},{"location":"api/db/#zodiac_core.db.session","title":"<code>zodiac_core.db.session</code>","text":""},{"location":"api/db/#zodiac_core.db.session.DEFAULT_DB_NAME","title":"<code>DEFAULT_DB_NAME = 'default'</code>  <code>module-attribute</code>","text":""},{"location":"api/db/#zodiac_core.db.session.db","title":"<code>db = DatabaseManager()</code>  <code>module-attribute</code>","text":""},{"location":"api/db/#zodiac_core.db.session.DatabaseManager","title":"<code>DatabaseManager</code>","text":"<p>Manages multiple Async Database Engines and Session Factories. Implemented as a Strict Singleton to coordinate connection pools.</p> <p>Integration Examples:</p> <ol> <li> <p>Native FastAPI (Lifespan + Depends):</p> <pre><code># main.py\nfrom contextlib import asynccontextmanager\nfrom fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom zodiac_core.db.session import db, get_session\n\n@asynccontextmanager\nasync def lifespan(app: FastAPI):\n    db.setup(\"sqlite+aiosqlite:///database.db\")\n    yield\n    await db.shutdown()\n\napp = FastAPI(lifespan=lifespan)\n\n@app.get(\"/items\")\nasync def list_items(session: AsyncSession = Depends(get_session)):\n    return {\"status\": \"ok\"}\n</code></pre> </li> <li> <p>Dependency Injector (Using provided init_db_resource):</p> <pre><code># containers.py\nfrom dependency_injector import containers, providers\nfrom zodiac_core.db.session import init_db_resource\n\nclass Container(containers.DeclarativeContainer):\n    config = providers.Configuration()\n\n    # Use the pre-built resource helper\n    db_manager = providers.Resource(\n        init_db_resource,\n        database_url=config.db.url,\n        echo=config.db.echo.as_bool(),\n    )\n</code></pre> </li> </ol> Source code in <code>zodiac_core/db/session.py</code> <pre><code>class DatabaseManager:\n    \"\"\"\n    Manages multiple Async Database Engines and Session Factories.\n    Implemented as a Strict Singleton to coordinate connection pools.\n\n    Integration Examples:\n\n    1. **Native FastAPI (Lifespan + Depends):**\n\n        ```python\n        # main.py\n        from contextlib import asynccontextmanager\n        from fastapi import FastAPI, Depends\n        from sqlalchemy.ext.asyncio import AsyncSession\n        from zodiac_core.db.session import db, get_session\n\n        @asynccontextmanager\n        async def lifespan(app: FastAPI):\n            db.setup(\"sqlite+aiosqlite:///database.db\")\n            yield\n            await db.shutdown()\n\n        app = FastAPI(lifespan=lifespan)\n\n        @app.get(\"/items\")\n        async def list_items(session: AsyncSession = Depends(get_session)):\n            return {\"status\": \"ok\"}\n        ```\n\n    2. **Dependency Injector (Using provided init_db_resource):**\n\n        ```python\n        # containers.py\n        from dependency_injector import containers, providers\n        from zodiac_core.db.session import init_db_resource\n\n        class Container(containers.DeclarativeContainer):\n            config = providers.Configuration()\n\n            # Use the pre-built resource helper\n            db_manager = providers.Resource(\n                init_db_resource,\n                database_url=config.db.url,\n                echo=config.db.echo.as_bool(),\n            )\n        ```\n    \"\"\"\n\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            cls._instance = super().__new__(cls)\n            cls._instance._engines: Dict[str, AsyncEngine] = {}\n            cls._instance._session_factories: Dict[str, async_sessionmaker[AsyncSession]] = {}\n        return cls._instance\n\n    def get_engine(self, name: str = DEFAULT_DB_NAME) -&gt; AsyncEngine:\n        \"\"\"Access a specific SQLAlchemy AsyncEngine by name.\"\"\"\n        if name not in self._engines:\n            raise RuntimeError(f\"Database engine '{name}' is not initialized. Call db.setup(name='{name}') first.\")\n        return self._engines[name]\n\n    def get_factory(self, name: str = DEFAULT_DB_NAME) -&gt; async_sessionmaker[AsyncSession]:\n        \"\"\"Access a specific AsyncSession factory by name.\"\"\"\n        if name not in self._session_factories:\n            raise RuntimeError(f\"Session factory for '{name}' is not initialized. Call db.setup(name='{name}') first.\")\n        return self._session_factories[name]\n\n    @property\n    def engine(self) -&gt; AsyncEngine:\n        \"\"\"Access the default SQLAlchemy AsyncEngine.\"\"\"\n        return self.get_engine(DEFAULT_DB_NAME)\n\n    @property\n    def session_factory(self) -&gt; async_sessionmaker[AsyncSession]:\n        \"\"\"Access the default AsyncSession factory.\"\"\"\n        return self.get_factory(DEFAULT_DB_NAME)\n\n    def setup(\n        self,\n        database_url: str,\n        name: str = DEFAULT_DB_NAME,\n        echo: bool = False,\n        pool_size: int = 10,\n        max_overflow: int = 20,\n        pool_pre_ping: bool = True,\n        connect_args: Optional[dict] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Initialize an Async Engine and Session Factory with a specific name.\"\"\"\n        if name in self._engines:\n            logger.warning(f\"Database '{name}' is already configured, skipping duplicate setup.\")\n            return\n\n        engine_args = {\n            \"echo\": echo,\n            \"pool_pre_ping\": pool_pre_ping,\n            \"connect_args\": connect_args or {},\n            **kwargs,\n        }\n\n        if \"sqlite\" not in database_url:\n            engine_args[\"pool_size\"] = pool_size\n            engine_args[\"max_overflow\"] = max_overflow\n\n        engine = create_async_engine(database_url, **engine_args)\n        factory = async_sessionmaker(\n            bind=engine,\n            class_=AsyncSession,\n            expire_on_commit=False,\n            autoflush=False,\n        )\n\n        self._engines[name] = engine\n        self._session_factories[name] = factory\n        logger.info(f\"Database '{name}' initialized successfully.\")\n\n    async def shutdown(self) -&gt; None:\n        \"\"\"Dispose of all registered engines and clear factories.\"\"\"\n        for engine in self._engines.values():\n            await engine.dispose()\n        self._engines.clear()\n        self._session_factories.clear()\n\n    @asynccontextmanager\n    async def session(self, name: str = DEFAULT_DB_NAME) -&gt; AsyncGenerator[AsyncSession, None]:\n        \"\"\"\n        Context Manager for obtaining a NEW database session from a specific engine.\n\n        Note:\n            This context manager does NOT auto-commit. You must explicitly call\n            `await session.commit()` to persist changes to the database.\n\n        Example:\n            ```python\n            async with db.session() as session:\n                session.add(user)\n                await session.commit()  # Required to persist changes\n            ```\n        \"\"\"\n        async with manage_session(self.get_factory(name)) as session:\n            yield session\n\n    async def verify(self, name: str = DEFAULT_DB_NAME) -&gt; bool:\n        \"\"\"\n        Verify the database connection is working.\n\n        Args:\n            name: The database name to verify.\n\n        Returns:\n            True if connection is successful.\n\n        Raises:\n            RuntimeError: If the database is not initialized.\n            Exception: If the connection test fails.\n        \"\"\"\n        async with self.session(name) as session:\n            await session.execute(text(\"SELECT 1\"))\n        logger.info(f\"Database '{name}' connection verified.\")\n        return True\n\n    async def create_all(self, name: str = DEFAULT_DB_NAME, metadata: Any = None) -&gt; None:\n        \"\"\"\n        Create tables in the database.\n\n        Args:\n            name: The database name to create tables in.\n            metadata: SQLAlchemy MetaData object. If None, uses SQLModel.metadata\n                      which includes ALL registered models. For production, consider\n                      using Alembic migrations instead.\n\n        Example:\n            ```python\n            # Development: create all tables\n            await db.create_all()\n\n            # With custom metadata (only specific tables)\n            from sqlalchemy import MetaData\n            my_metadata = MetaData()\n            await db.create_all(metadata=my_metadata)\n            ```\n        \"\"\"\n        target_metadata = metadata if metadata is not None else SQLModel.metadata\n        async with self.get_engine(name).begin() as conn:\n            await conn.run_sync(target_metadata.create_all)\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.engine","title":"<code>engine</code>  <code>property</code>","text":"<p>Access the default SQLAlchemy AsyncEngine.</p>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.session_factory","title":"<code>session_factory</code>  <code>property</code>","text":"<p>Access the default AsyncSession factory.</p>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.create_all","title":"<code>create_all(name=DEFAULT_DB_NAME, metadata=None)</code>  <code>async</code>","text":"<p>Create tables in the database.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The database name to create tables in.</p> <code>DEFAULT_DB_NAME</code> <code>metadata</code> <code>Any</code> <p>SQLAlchemy MetaData object. If None, uses SQLModel.metadata       which includes ALL registered models. For production, consider       using Alembic migrations instead.</p> <code>None</code> Example <pre><code># Development: create all tables\nawait db.create_all()\n\n# With custom metadata (only specific tables)\nfrom sqlalchemy import MetaData\nmy_metadata = MetaData()\nawait db.create_all(metadata=my_metadata)\n</code></pre> Source code in <code>zodiac_core/db/session.py</code> <pre><code>async def create_all(self, name: str = DEFAULT_DB_NAME, metadata: Any = None) -&gt; None:\n    \"\"\"\n    Create tables in the database.\n\n    Args:\n        name: The database name to create tables in.\n        metadata: SQLAlchemy MetaData object. If None, uses SQLModel.metadata\n                  which includes ALL registered models. For production, consider\n                  using Alembic migrations instead.\n\n    Example:\n        ```python\n        # Development: create all tables\n        await db.create_all()\n\n        # With custom metadata (only specific tables)\n        from sqlalchemy import MetaData\n        my_metadata = MetaData()\n        await db.create_all(metadata=my_metadata)\n        ```\n    \"\"\"\n    target_metadata = metadata if metadata is not None else SQLModel.metadata\n    async with self.get_engine(name).begin() as conn:\n        await conn.run_sync(target_metadata.create_all)\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.get_engine","title":"<code>get_engine(name=DEFAULT_DB_NAME)</code>","text":"<p>Access a specific SQLAlchemy AsyncEngine by name.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>def get_engine(self, name: str = DEFAULT_DB_NAME) -&gt; AsyncEngine:\n    \"\"\"Access a specific SQLAlchemy AsyncEngine by name.\"\"\"\n    if name not in self._engines:\n        raise RuntimeError(f\"Database engine '{name}' is not initialized. Call db.setup(name='{name}') first.\")\n    return self._engines[name]\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.get_factory","title":"<code>get_factory(name=DEFAULT_DB_NAME)</code>","text":"<p>Access a specific AsyncSession factory by name.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>def get_factory(self, name: str = DEFAULT_DB_NAME) -&gt; async_sessionmaker[AsyncSession]:\n    \"\"\"Access a specific AsyncSession factory by name.\"\"\"\n    if name not in self._session_factories:\n        raise RuntimeError(f\"Session factory for '{name}' is not initialized. Call db.setup(name='{name}') first.\")\n    return self._session_factories[name]\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.session","title":"<code>session(name=DEFAULT_DB_NAME)</code>  <code>async</code>","text":"<p>Context Manager for obtaining a NEW database session from a specific engine.</p> Note <p>This context manager does NOT auto-commit. You must explicitly call <code>await session.commit()</code> to persist changes to the database.</p> Example <pre><code>async with db.session() as session:\n    session.add(user)\n    await session.commit()  # Required to persist changes\n</code></pre> Source code in <code>zodiac_core/db/session.py</code> <pre><code>@asynccontextmanager\nasync def session(self, name: str = DEFAULT_DB_NAME) -&gt; AsyncGenerator[AsyncSession, None]:\n    \"\"\"\n    Context Manager for obtaining a NEW database session from a specific engine.\n\n    Note:\n        This context manager does NOT auto-commit. You must explicitly call\n        `await session.commit()` to persist changes to the database.\n\n    Example:\n        ```python\n        async with db.session() as session:\n            session.add(user)\n            await session.commit()  # Required to persist changes\n        ```\n    \"\"\"\n    async with manage_session(self.get_factory(name)) as session:\n        yield session\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.setup","title":"<code>setup(database_url, name=DEFAULT_DB_NAME, echo=False, pool_size=10, max_overflow=20, pool_pre_ping=True, connect_args=None, **kwargs)</code>","text":"<p>Initialize an Async Engine and Session Factory with a specific name.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>def setup(\n    self,\n    database_url: str,\n    name: str = DEFAULT_DB_NAME,\n    echo: bool = False,\n    pool_size: int = 10,\n    max_overflow: int = 20,\n    pool_pre_ping: bool = True,\n    connect_args: Optional[dict] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Initialize an Async Engine and Session Factory with a specific name.\"\"\"\n    if name in self._engines:\n        logger.warning(f\"Database '{name}' is already configured, skipping duplicate setup.\")\n        return\n\n    engine_args = {\n        \"echo\": echo,\n        \"pool_pre_ping\": pool_pre_ping,\n        \"connect_args\": connect_args or {},\n        **kwargs,\n    }\n\n    if \"sqlite\" not in database_url:\n        engine_args[\"pool_size\"] = pool_size\n        engine_args[\"max_overflow\"] = max_overflow\n\n    engine = create_async_engine(database_url, **engine_args)\n    factory = async_sessionmaker(\n        bind=engine,\n        class_=AsyncSession,\n        expire_on_commit=False,\n        autoflush=False,\n    )\n\n    self._engines[name] = engine\n    self._session_factories[name] = factory\n    logger.info(f\"Database '{name}' initialized successfully.\")\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.shutdown","title":"<code>shutdown()</code>  <code>async</code>","text":"<p>Dispose of all registered engines and clear factories.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>async def shutdown(self) -&gt; None:\n    \"\"\"Dispose of all registered engines and clear factories.\"\"\"\n    for engine in self._engines.values():\n        await engine.dispose()\n    self._engines.clear()\n    self._session_factories.clear()\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.DatabaseManager.verify","title":"<code>verify(name=DEFAULT_DB_NAME)</code>  <code>async</code>","text":"<p>Verify the database connection is working.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The database name to verify.</p> <code>DEFAULT_DB_NAME</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if connection is successful.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the database is not initialized.</p> <code>Exception</code> <p>If the connection test fails.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>async def verify(self, name: str = DEFAULT_DB_NAME) -&gt; bool:\n    \"\"\"\n    Verify the database connection is working.\n\n    Args:\n        name: The database name to verify.\n\n    Returns:\n        True if connection is successful.\n\n    Raises:\n        RuntimeError: If the database is not initialized.\n        Exception: If the connection test fails.\n    \"\"\"\n    async with self.session(name) as session:\n        await session.execute(text(\"SELECT 1\"))\n    logger.info(f\"Database '{name}' connection verified.\")\n    return True\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.get_session","title":"<code>get_session()</code>  <code>async</code>","text":"<p>FastAPI Dependency for obtaining a default database session.</p> Note <p>This dependency does NOT auto-commit. You must explicitly call <code>await session.commit()</code> within your endpoint to persist changes.</p> Example <pre><code>@app.post(\"/users\")\nasync def create_user(session: AsyncSession = Depends(get_session)):\n    user = User(name=\"test\")\n    session.add(user)\n    await session.commit()  # Required to persist changes\n    return user\n</code></pre> Source code in <code>zodiac_core/db/session.py</code> <pre><code>async def get_session() -&gt; AsyncGenerator[AsyncSession, None]:\n    \"\"\"\n    FastAPI Dependency for obtaining a default database session.\n\n    Note:\n        This dependency does NOT auto-commit. You must explicitly call\n        `await session.commit()` within your endpoint to persist changes.\n\n    Example:\n        ```python\n        @app.post(\"/users\")\n        async def create_user(session: AsyncSession = Depends(get_session)):\n            user = User(name=\"test\")\n            session.add(user)\n            await session.commit()  # Required to persist changes\n            return user\n        ```\n    \"\"\"\n    async with db.session() as session:\n        yield session\n</code></pre>"},{"location":"api/db/#zodiac_core.db.session.init_db_resource","title":"<code>init_db_resource(database_url, name=DEFAULT_DB_NAME, echo=False, connect_args=None, **kwargs)</code>  <code>async</code>","text":"<p>A helper for dependency_injector's Resource provider. Handles the setup and shutdown lifecycle of the global <code>db</code> instance.</p> Source code in <code>zodiac_core/db/session.py</code> <pre><code>async def init_db_resource(\n    database_url: str,\n    name: str = DEFAULT_DB_NAME,\n    echo: bool = False,\n    connect_args: Optional[dict] = None,\n    **kwargs,\n) -&gt; AsyncGenerator[DatabaseManager, None]:\n    \"\"\"\n    A helper for dependency_injector's Resource provider.\n    Handles the setup and shutdown lifecycle of the global `db` instance.\n    \"\"\"\n    db.setup(database_url=database_url, name=name, echo=echo, connect_args=connect_args, **kwargs)\n    try:\n        yield db\n    finally:\n        await db.shutdown()\n</code></pre>"},{"location":"api/db/#repository-base","title":"Repository Base","text":""},{"location":"api/db/#zodiac_core.db.repository.BaseSQLRepository","title":"<code>zodiac_core.db.repository.BaseSQLRepository</code>","text":"<p>Standard base class for SQL-based repositories.</p> <p>Supports multiple database instances via <code>db_name</code> and provides professional utilities for common operations like pagination.</p> Source code in <code>zodiac_core/db/repository.py</code> <pre><code>class BaseSQLRepository:\n    \"\"\"\n    Standard base class for SQL-based repositories.\n\n    Supports multiple database instances via `db_name` and provides\n    professional utilities for common operations like pagination.\n    \"\"\"\n\n    def __init__(\n        self,\n        session_factory: Optional[async_sessionmaker[AsyncSession]] = None,\n        db_name: str = DEFAULT_DB_NAME,\n        options: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the repository.\n\n        Args:\n            session_factory: Optional custom session factory. If provided, db_name is ignored.\n            db_name: The name of the database engine registered in db.setup(). Defaults to DEFAULT_DB_NAME (\"default\").\n            options: Optional configuration/options for the repository.\n        \"\"\"\n        self._session_factory = session_factory\n        self.db_name = db_name\n        self.options = options\n\n    @asynccontextmanager\n    async def session(self) -&gt; AsyncIterator[AsyncSession]:\n        \"\"\"\n        Async context manager for obtaining a database session.\n        Uses the injected factory or resolves one from the global 'db' via 'db_name'.\n\n        Note:\n            This context manager does NOT auto-commit. You must explicitly call\n            `await session.commit()` to persist changes to the database.\n        \"\"\"\n        factory = self._session_factory or db.get_factory(self.db_name)\n        async with manage_session(factory) as session:\n            yield session\n\n    async def paginate(\n        self,\n        session: AsyncSession,\n        statement: Any,\n        params: PageParams,\n        transformer: Optional[Type[T]] = None,\n    ) -&gt; PagedResponse[T]:\n        \"\"\"\n        Execute a paginated query with automatic count and paging.\n\n        Performs:\n        1. Automatic total count query using the provided statement.\n        2. Automatic limit/offset application.\n        3. Packaging results into a standardized PagedResponse.\n\n        Args:\n            session: The active AsyncSession.\n            statement: The SQLAlchemy select statement (without limit/offset).\n            params: Standard PageParams (page, size).\n            transformer: Optional Pydantic model to transform DB objects into.\n\n        Example:\n            ```python\n            async with self.session() as session:\n                stmt = select(UserModel).order_by(UserModel.created_at.desc())\n                return await self.paginate(session, stmt, params)\n            ```\n        \"\"\"\n        # 1. Execute Count Query\n        # Remove limit/offset (if any) for count query, then wrap in subquery\n        # subquery() handles order_by correctly, and wrapping in subquery handles complex queries (joins, groups)\n        count_base = statement.limit(None).offset(None)\n        count_stmt = select(func.count()).select_from(count_base.subquery())\n        total = (await session.execute(count_stmt)).scalar() or 0\n\n        # 2. Execute Paged Query\n        skip = (params.page - 1) * params.size\n        paged_stmt = statement.offset(skip).limit(params.size)\n        result = await session.execute(paged_stmt)\n        items = result.scalars().all()\n\n        # 3. Optional Transformation\n        if transformer:\n            items = [transformer.model_validate(item) for item in items]\n\n        return PagedResponse.create(items=list(items), total=total, params=params)\n\n    async def paginate_query(\n        self,\n        statement: Any,\n        params: PageParams,\n        transformer: Optional[Type[T]] = None,\n    ) -&gt; PagedResponse[T]:\n        \"\"\"\n        Convenience method that automatically manages session for pagination.\n\n        This is a wrapper around `paginate()` that handles session management,\n        making it easier to use in repository methods.\n\n        Args:\n            statement: The SQLAlchemy select statement (without limit/offset).\n            params: Standard PageParams (page, size).\n            transformer: Optional Pydantic model to transform DB objects into.\n\n        Example:\n            ```python\n            async def list_items(self, params: PageParams) -&gt; PagedResponse[ItemModel]:\n                stmt = select(ItemModel).order_by(ItemModel.id)\n                return await self.paginate_query(stmt, params)\n            ```\n        \"\"\"\n        async with self.session() as session:\n            return await self.paginate(session, statement, params, transformer)\n</code></pre>"},{"location":"api/db/#zodiac_core.db.repository.BaseSQLRepository.__init__","title":"<code>__init__(session_factory=None, db_name=DEFAULT_DB_NAME, options=None)</code>","text":"<p>Initialize the repository.</p> <p>Parameters:</p> Name Type Description Default <code>session_factory</code> <code>Optional[async_sessionmaker[AsyncSession]]</code> <p>Optional custom session factory. If provided, db_name is ignored.</p> <code>None</code> <code>db_name</code> <code>str</code> <p>The name of the database engine registered in db.setup(). Defaults to DEFAULT_DB_NAME (\"default\").</p> <code>DEFAULT_DB_NAME</code> <code>options</code> <code>Optional[Any]</code> <p>Optional configuration/options for the repository.</p> <code>None</code> Source code in <code>zodiac_core/db/repository.py</code> <pre><code>def __init__(\n    self,\n    session_factory: Optional[async_sessionmaker[AsyncSession]] = None,\n    db_name: str = DEFAULT_DB_NAME,\n    options: Optional[Any] = None,\n) -&gt; None:\n    \"\"\"\n    Initialize the repository.\n\n    Args:\n        session_factory: Optional custom session factory. If provided, db_name is ignored.\n        db_name: The name of the database engine registered in db.setup(). Defaults to DEFAULT_DB_NAME (\"default\").\n        options: Optional configuration/options for the repository.\n    \"\"\"\n    self._session_factory = session_factory\n    self.db_name = db_name\n    self.options = options\n</code></pre>"},{"location":"api/db/#zodiac_core.db.repository.BaseSQLRepository.paginate","title":"<code>paginate(session, statement, params, transformer=None)</code>  <code>async</code>","text":"<p>Execute a paginated query with automatic count and paging.</p> <p>Performs: 1. Automatic total count query using the provided statement. 2. Automatic limit/offset application. 3. Packaging results into a standardized PagedResponse.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The active AsyncSession.</p> required <code>statement</code> <code>Any</code> <p>The SQLAlchemy select statement (without limit/offset).</p> required <code>params</code> <code>PageParams</code> <p>Standard PageParams (page, size).</p> required <code>transformer</code> <code>Optional[Type[T]]</code> <p>Optional Pydantic model to transform DB objects into.</p> <code>None</code> Example <pre><code>async with self.session() as session:\n    stmt = select(UserModel).order_by(UserModel.created_at.desc())\n    return await self.paginate(session, stmt, params)\n</code></pre> Source code in <code>zodiac_core/db/repository.py</code> <pre><code>async def paginate(\n    self,\n    session: AsyncSession,\n    statement: Any,\n    params: PageParams,\n    transformer: Optional[Type[T]] = None,\n) -&gt; PagedResponse[T]:\n    \"\"\"\n    Execute a paginated query with automatic count and paging.\n\n    Performs:\n    1. Automatic total count query using the provided statement.\n    2. Automatic limit/offset application.\n    3. Packaging results into a standardized PagedResponse.\n\n    Args:\n        session: The active AsyncSession.\n        statement: The SQLAlchemy select statement (without limit/offset).\n        params: Standard PageParams (page, size).\n        transformer: Optional Pydantic model to transform DB objects into.\n\n    Example:\n        ```python\n        async with self.session() as session:\n            stmt = select(UserModel).order_by(UserModel.created_at.desc())\n            return await self.paginate(session, stmt, params)\n        ```\n    \"\"\"\n    # 1. Execute Count Query\n    # Remove limit/offset (if any) for count query, then wrap in subquery\n    # subquery() handles order_by correctly, and wrapping in subquery handles complex queries (joins, groups)\n    count_base = statement.limit(None).offset(None)\n    count_stmt = select(func.count()).select_from(count_base.subquery())\n    total = (await session.execute(count_stmt)).scalar() or 0\n\n    # 2. Execute Paged Query\n    skip = (params.page - 1) * params.size\n    paged_stmt = statement.offset(skip).limit(params.size)\n    result = await session.execute(paged_stmt)\n    items = result.scalars().all()\n\n    # 3. Optional Transformation\n    if transformer:\n        items = [transformer.model_validate(item) for item in items]\n\n    return PagedResponse.create(items=list(items), total=total, params=params)\n</code></pre>"},{"location":"api/db/#zodiac_core.db.repository.BaseSQLRepository.paginate_query","title":"<code>paginate_query(statement, params, transformer=None)</code>  <code>async</code>","text":"<p>Convenience method that automatically manages session for pagination.</p> <p>This is a wrapper around <code>paginate()</code> that handles session management, making it easier to use in repository methods.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Any</code> <p>The SQLAlchemy select statement (without limit/offset).</p> required <code>params</code> <code>PageParams</code> <p>Standard PageParams (page, size).</p> required <code>transformer</code> <code>Optional[Type[T]]</code> <p>Optional Pydantic model to transform DB objects into.</p> <code>None</code> Example <pre><code>async def list_items(self, params: PageParams) -&gt; PagedResponse[ItemModel]:\n    stmt = select(ItemModel).order_by(ItemModel.id)\n    return await self.paginate_query(stmt, params)\n</code></pre> Source code in <code>zodiac_core/db/repository.py</code> <pre><code>async def paginate_query(\n    self,\n    statement: Any,\n    params: PageParams,\n    transformer: Optional[Type[T]] = None,\n) -&gt; PagedResponse[T]:\n    \"\"\"\n    Convenience method that automatically manages session for pagination.\n\n    This is a wrapper around `paginate()` that handles session management,\n    making it easier to use in repository methods.\n\n    Args:\n        statement: The SQLAlchemy select statement (without limit/offset).\n        params: Standard PageParams (page, size).\n        transformer: Optional Pydantic model to transform DB objects into.\n\n    Example:\n        ```python\n        async def list_items(self, params: PageParams) -&gt; PagedResponse[ItemModel]:\n            stmt = select(ItemModel).order_by(ItemModel.id)\n            return await self.paginate_query(stmt, params)\n        ```\n    \"\"\"\n    async with self.session() as session:\n        return await self.paginate(session, statement, params, transformer)\n</code></pre>"},{"location":"api/db/#zodiac_core.db.repository.BaseSQLRepository.session","title":"<code>session()</code>  <code>async</code>","text":"<p>Async context manager for obtaining a database session. Uses the injected factory or resolves one from the global 'db' via 'db_name'.</p> Note <p>This context manager does NOT auto-commit. You must explicitly call <code>await session.commit()</code> to persist changes to the database.</p> Source code in <code>zodiac_core/db/repository.py</code> <pre><code>@asynccontextmanager\nasync def session(self) -&gt; AsyncIterator[AsyncSession]:\n    \"\"\"\n    Async context manager for obtaining a database session.\n    Uses the injected factory or resolves one from the global 'db' via 'db_name'.\n\n    Note:\n        This context manager does NOT auto-commit. You must explicitly call\n        `await session.commit()` to persist changes to the database.\n    \"\"\"\n    factory = self._session_factory or db.get_factory(self.db_name)\n    async with manage_session(factory) as session:\n        yield session\n</code></pre>"},{"location":"api/db/#sql-models-mixins","title":"SQL Models &amp; Mixins","text":""},{"location":"api/db/#zodiac_core.db.sql","title":"<code>zodiac_core.db.sql</code>","text":""},{"location":"api/db/#zodiac_core.db.sql.IntIDModel","title":"<code>IntIDModel</code>","text":"<p>               Bases: <code>SQLBase</code>, <code>IntIDMixin</code></p> <p>Base SQLModel with Integer ID and Timestamps. Includes: ID (int) + CreatedAt + UpdatedAt.</p> Source code in <code>zodiac_core/db/sql.py</code> <pre><code>class IntIDModel(SQLBase, IntIDMixin):\n    \"\"\"\n    Base SQLModel with Integer ID and Timestamps.\n    Includes: ID (int) + CreatedAt + UpdatedAt.\n    \"\"\"\n</code></pre>"},{"location":"api/db/#zodiac_core.db.sql.UUIDModel","title":"<code>UUIDModel</code>","text":"<p>               Bases: <code>SQLBase</code>, <code>UUIDMixin</code></p> <p>Base SQLModel with UUID and Timestamps. Includes: ID (UUID) + CreatedAt + UpdatedAt.</p> Source code in <code>zodiac_core/db/sql.py</code> <pre><code>class UUIDModel(SQLBase, UUIDMixin):\n    \"\"\"\n    Base SQLModel with UUID and Timestamps.\n    Includes: ID (UUID) + CreatedAt + UpdatedAt.\n    \"\"\"\n</code></pre>"},{"location":"api/db/#zodiac_core.db.sql.SQLDateTimeMixin","title":"<code>SQLDateTimeMixin</code>","text":"<p>               Bases: <code>SQLModel</code></p> <p>Mixin for created_at and updated_at with SQLAlchemy server-side defaults. Supports PostgreSQL, MySQL, and SQLite with proper UTC handling.</p> Source code in <code>zodiac_core/db/sql.py</code> <pre><code>class SQLDateTimeMixin(SQLModel):\n    \"\"\"\n    Mixin for created_at and updated_at with SQLAlchemy server-side defaults.\n    Supports PostgreSQL, MySQL, and SQLite with proper UTC handling.\n    \"\"\"\n\n    created_at: datetime = Field(\n        default_factory=utc_now,\n        sa_column_kwargs={\n            \"server_default\": utcnow(),\n            \"nullable\": False,\n        },\n        sa_type=DateTime(timezone=True),\n        description=\"Record creation timestamp (UTC)\",\n    )\n    updated_at: datetime = Field(\n        default_factory=utc_now,\n        sa_column_kwargs={\n            \"server_default\": utcnow(),\n            \"onupdate\": utcnow(),\n            \"nullable\": False,\n        },\n        sa_type=DateTime(timezone=True),\n        description=\"Record last update timestamp (UTC)\",\n    )\n</code></pre>"},{"location":"api/exceptions/","title":"Exception Handling","text":"<p>ZodiacCore provides a centralized exception handling system that automatically converts Python exceptions into standardized, production-ready JSON responses.</p>"},{"location":"api/exceptions/#1-core-concepts","title":"1. Core Concepts","text":""},{"location":"api/exceptions/#the-zodiacexception-base","title":"The ZodiacException Base","text":"<p>All business logic errors should inherit from <code>ZodiacException</code>. This base class allows you to define:</p> <ul> <li><code>http_code</code>: The HTTP status code (e.g., 404, 400).</li> <li><code>code</code>: A custom business error code.</li> <li><code>message</code>: A human-readable error description.</li> <li><code>data</code>: Optional payload for additional error details (e.g., validation errors).</li> </ul>"},{"location":"api/exceptions/#automatic-transformation","title":"Automatic Transformation","text":"<p>When a <code>ZodiacException</code> is raised, the <code>handler_zodiac_exception</code> exception handler catches it and transforms it into a standard JSON response:</p> <pre><code>{\n  \"code\": 404,\n  \"message\": \"Resource not found\",\n  \"data\": null\n}\n</code></pre>"},{"location":"api/exceptions/#2-validation-errors-http-422","title":"2. Validation Errors (HTTP 422)","text":"<p>One of the best features of ZodiacCore is that it also standardizes framework-level validation errors. When a user sends invalid JSON or missing parameters, FastAPI normally returns a custom structure. ZodiacCore catches these and wraps them in our standard format:</p> <pre><code>{\n  \"code\": 422,\n  \"message\": \"Unprocessable Entity\",\n  \"data\": [\n    {\n      \"type\": \"missing\",\n      \"loc\": [\"body\", \"username\"],\n      \"msg\": \"Field required\",\n      \"input\": null\n    }\n  ]\n}\n</code></pre> <p>This ensures your API is 100% consistent, whether the error came from your business logic or from a schema mismatch.</p>"},{"location":"api/exceptions/#3-built-in-exceptions","title":"3. Built-in Exceptions","text":"<p>ZodiacCore includes several common exceptions ready to use:</p> Exception HTTP Status Use Case <code>BadRequestException</code> 400 Invalid input or parameters. <code>UnauthorizedException</code> 401 Missing or invalid authentication. <code>ForbiddenException</code> 403 Insufficient permissions. <code>NotFoundException</code> 404 Resource does not exist. <code>ConflictException</code> 409 Resource state conflict (e.g., duplicate entry)."},{"location":"api/exceptions/#4-custom-exceptions","title":"4. Custom Exceptions","text":"<p>Creating your own business exception is simple:</p> <pre><code>from zodiac_core.exceptions import ZodiacException\nfrom fastapi import status\n\nclass InsufficientBalanceException(ZodiacException):\n    # Set default HTTP code\n    http_code = status.HTTP_400_BAD_REQUEST\n\n    def __init__(self, current_balance: float):\n        super().__init__(\n            code=1001, # Custom business code\n            message=\"Your account balance is too low.\",\n            data={\"current_balance\": current_balance}\n        )\n</code></pre> <p>Usage in a route: <pre><code>@app.post(\"/transfer\")\nasync def transfer_money(amount: float):\n    if amount &gt; user.balance:\n        raise InsufficientBalanceException(user.balance)\n    ...\n</code></pre></p>"},{"location":"api/exceptions/#5-integration","title":"5. Integration","text":"<p>To enable global exception handling in your FastAPI app, use <code>register_exception_handlers</code>. This will catch:</p> <ol> <li>All <code>ZodiacException</code> subclasses.</li> <li>Pydantic <code>ValidationError</code> and FastAPI <code>RequestValidationError</code> (mapped to 422).</li> <li>Any uncaught <code>Exception</code> (mapped to 500 with secure logging).</li> </ol> <pre><code>from fastapi import FastAPI\nfrom zodiac_core.exception_handlers import register_exception_handlers\n\napp = FastAPI()\nregister_exception_handlers(app)\n</code></pre>"},{"location":"api/exceptions/#6-api-reference","title":"6. API Reference","text":""},{"location":"api/exceptions/#exception-base-subclasses","title":"Exception Base &amp; Subclasses","text":""},{"location":"api/exceptions/#zodiac_core.exceptions.ZodiacException","title":"<code>ZodiacException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base class for all zodiac-core related errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class ZodiacException(Exception):\n    \"\"\"Base class for all zodiac-core related errors.\"\"\"\n\n    http_code: int = status.HTTP_500_INTERNAL_SERVER_ERROR\n\n    def __init__(\n        self,\n        code: Optional[int] = None,\n        data: Any = None,\n        message: Optional[str] = None,\n    ):\n        self.code = code or self.http_code\n        self.data = data\n        if message is not None:\n            self.message = message\n        super().__init__(message)\n</code></pre>"},{"location":"api/exceptions/#zodiac_core.exceptions.BadRequestException","title":"<code>BadRequestException</code>","text":"<p>               Bases: <code>ZodiacException</code></p> <p>Exception raised for 400 Bad Request errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class BadRequestException(ZodiacException):\n    \"\"\"Exception raised for 400 Bad Request errors.\"\"\"\n\n    http_code = status.HTTP_400_BAD_REQUEST\n</code></pre>"},{"location":"api/exceptions/#zodiac_core.exceptions.UnauthorizedException","title":"<code>UnauthorizedException</code>","text":"<p>               Bases: <code>ZodiacException</code></p> <p>Exception raised for 401 Unauthorized errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class UnauthorizedException(ZodiacException):\n    \"\"\"Exception raised for 401 Unauthorized errors.\"\"\"\n\n    http_code = status.HTTP_401_UNAUTHORIZED\n</code></pre>"},{"location":"api/exceptions/#zodiac_core.exceptions.ForbiddenException","title":"<code>ForbiddenException</code>","text":"<p>               Bases: <code>ZodiacException</code></p> <p>Exception raised for 403 Forbidden errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class ForbiddenException(ZodiacException):\n    \"\"\"Exception raised for 403 Forbidden errors.\"\"\"\n\n    http_code = status.HTTP_403_FORBIDDEN\n</code></pre>"},{"location":"api/exceptions/#zodiac_core.exceptions.NotFoundException","title":"<code>NotFoundException</code>","text":"<p>               Bases: <code>ZodiacException</code></p> <p>Exception raised for 404 Not Found errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class NotFoundException(ZodiacException):\n    \"\"\"Exception raised for 404 Not Found errors.\"\"\"\n\n    http_code = status.HTTP_404_NOT_FOUND\n</code></pre>"},{"location":"api/exceptions/#zodiac_core.exceptions.ConflictException","title":"<code>ConflictException</code>","text":"<p>               Bases: <code>ZodiacException</code></p> <p>Exception raised for 409 Conflict errors.</p> Source code in <code>zodiac_core/exceptions.py</code> <pre><code>class ConflictException(ZodiacException):\n    \"\"\"Exception raised for 409 Conflict errors.\"\"\"\n\n    http_code = status.HTTP_409_CONFLICT\n</code></pre>"},{"location":"api/exceptions/#global-handler-registration","title":"Global Handler Registration","text":""},{"location":"api/exceptions/#zodiac_core.exception_handlers.register_exception_handlers","title":"<code>register_exception_handlers(app)</code>","text":"<p>Register all exception handlers to the FastAPI app.</p> <p>Order matters: 1. Specific Validation Errors 2. Custom Business Logic Errors (ZodiacException) 3. Global Catch-All (Exception)</p> Source code in <code>zodiac_core/exception_handlers.py</code> <pre><code>def register_exception_handlers(app: FastAPI) -&gt; None:\n    \"\"\"\n    Register all exception handlers to the FastAPI app.\n\n    Order matters:\n    1. Specific Validation Errors\n    2. Custom Business Logic Errors (ZodiacException)\n    3. Global Catch-All (Exception)\n    \"\"\"\n    app.add_exception_handler(RequestValidationError, handler_validation_exception)\n    app.add_exception_handler(ValidationError, handler_validation_exception)\n    app.add_exception_handler(ZodiacException, handler_zodiac_exception)\n    app.add_exception_handler(Exception, handler_global_exception)\n</code></pre>"},{"location":"api/logging/","title":"Logging &amp; Observability","text":"<p>ZodiacCore provides a pre-configured, production-ready logging system based on Loguru. It is designed for observability, supporting JSON structured logs and automatic Trace ID correlation.</p>"},{"location":"api/logging/#1-core-concepts","title":"1. Core Concepts","text":""},{"location":"api/logging/#structured-logging","title":"Structured Logging","text":"<p>By default, ZodiacCore outputs logs in JSON format. This is ideal for production environments (e.g., ELK stack, Datadog, CloudWatch) as it makes log parsing and searching significantly easier.</p>"},{"location":"api/logging/#trace-id-correlation","title":"Trace ID Correlation","text":"<p>Every log message automatically includes a <code>request_id</code> if it was generated during an active web request. This allows you to correlate multiple log lines across different services for a single transaction.</p>"},{"location":"api/logging/#2-quick-setup","title":"2. Quick Setup","text":"<p>The most common way to initialize logging is in your application's entry point (<code>main.py</code>).</p> <pre><code>from zodiac_core.logging import setup_loguru\n\nsetup_loguru(\n    level=\"INFO\",\n    json_format=True,        # Use JSON for production\n    service_name=\"payment-service\"\n)\n</code></pre>"},{"location":"api/logging/#3-advanced-configuration","title":"3. Advanced Configuration","text":""},{"location":"api/logging/#console-file-output","title":"Console &amp; File Output","text":"<p>You can log to both the console and a file simultaneously.</p> <pre><code>from zodiac_core.logging import setup_loguru, LogFileOptions\n\nsetup_loguru(\n    level=\"DEBUG\",\n    json_format=False,       # Use human-readable text for local dev\n    log_file=\"logs/app.log\",\n    file_options=LogFileOptions(\n        rotation=\"500 MB\",\n        retention=\"10 days\",\n        compression=\"zip\"\n    )\n)\n</code></pre>"},{"location":"api/logging/#passing-extra-sink-options","title":"Passing Extra Sink Options","text":"<p>The <code>console_options</code> argument allows you to pass arbitrary keyword arguments directly to the Loguru <code>add()</code> method.</p> <pre><code>setup_loguru(\n    console_options={\"enqueue\": True, \"backtrace\": True, \"diagnose\": True}\n)\n</code></pre>"},{"location":"api/logging/#4-how-to-log","title":"4. How to Log","text":"<p>Since ZodiacCore configures the standard <code>loguru.logger</code>, you can simply import and use it anywhere in your code.</p> <pre><code>from loguru import logger\n\ndef process_data(data):\n    logger.info(\"Processing data\", extra={\"data_id\": data.id})\n    # If this runs during a request, 'request_id' is automatically added!\n</code></pre>"},{"location":"api/logging/#5-json-log-structure","title":"5. JSON Log Structure","text":"<p>A typical JSON log entry produced by ZodiacCore looks like this:</p> <pre><code>{\n  \"text\": \"2026-01-31 17:26:24.208 | INFO     | demo_r:read_item:23 - request: item_id=1\\n\",\n  \"record\": {\n    \"elapsed\": {\n      \"repr\": \"0:00:14.429585\",\n      \"seconds\": 14.429585\n    },\n    \"exception\": null,\n    \"extra\": {\n      \"request_id\": \"98277dc9-27ca-4849-98f0-6097c3b41867\",\n      \"service\": \"service\"\n    },\n    \"file\": {\n      \"name\": \"demo_r.py\",\n      \"path\": \"/Users/legolas/workspace/ZodiacCore-Py/demo_r.py\"\n    },\n    \"function\": \"read_item\",\n    \"level\": {\n      \"icon\": \"\u2139\ufe0f\",\n      \"name\": \"INFO\",\n      \"no\": 20\n    },\n    \"line\": 23,\n    \"message\": \"request: item_id=1\",\n    \"module\": \"demo_r\",\n    \"name\": \"demo_r\",\n    \"process\": {\n      \"id\": 92473,\n      \"name\": \"MainProcess\"\n    },\n    \"thread\": {\n      \"id\": 140704462000000,\n      \"name\": \"MainThread\"\n    },\n    \"time\": {\n      \"repr\": \"2026-01-31 17:26:24.208560+08:00\",\n      \"timestamp\": 1769851584.20856\n    }\n  }\n}\n</code></pre>"},{"location":"api/logging/#6-api-reference","title":"6. API Reference","text":""},{"location":"api/logging/#logging-utilities","title":"Logging Utilities","text":""},{"location":"api/logging/#zodiac_core.logging.LogFileOptions","title":"<code>LogFileOptions</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configuration options for file logging.</p> <p>Allows arbitrary extra arguments to be passed to loguru.add() via extra=\"allow\".</p> Source code in <code>zodiac_core/logging.py</code> <pre><code>class LogFileOptions(BaseModel):\n    \"\"\"\n    Configuration options for file logging.\n\n    Allows arbitrary extra arguments to be passed to loguru.add() via extra=\"allow\".\n    \"\"\"\n\n    rotation: str = \"10 MB\"\n    retention: str = \"1 week\"\n    compression: str = \"zip\"\n    enqueue: bool = False\n    encoding: str = \"utf-8\"\n\n    model_config = ConfigDict(extra=\"allow\")\n</code></pre>"},{"location":"api/logging/#zodiac_core.logging.setup_loguru","title":"<code>setup_loguru(level='INFO', json_format=True, service_name='service', log_file=None, console_options=None, file_options=None)</code>","text":"<p>Configure Loguru with automatic Trace ID injection and multi-destination output.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>Logging level (INFO, DEBUG, etc.)</p> <code>'INFO'</code> <code>json_format</code> <code>bool</code> <p>Whether to output JSON (True) or Text (False).</p> <code>True</code> <code>service_name</code> <code>str</code> <p>Name of the service (added to JSON logs).</p> <code>'service'</code> <code>log_file</code> <code>Optional[str]</code> <p>Optional file path to save logs.</p> <code>None</code> <code>console_options</code> <code>Optional[Dict[str, Any]]</code> <p>Extra kwargs to pass to the console sink (e.g. {\"enqueue\": True}).</p> <code>None</code> <code>file_options</code> <code>Optional[LogFileOptions]</code> <p>Configuration model (LogFileOptions) for file sink.</p> <code>None</code> Source code in <code>zodiac_core/logging.py</code> <pre><code>def setup_loguru(\n    level: str = \"INFO\",\n    json_format: bool = True,\n    service_name: str = \"service\",\n    log_file: Optional[str] = None,\n    console_options: Optional[Dict[str, Any]] = None,\n    file_options: Optional[LogFileOptions] = None,\n):\n    \"\"\"\n    Configure Loguru with automatic Trace ID injection and multi-destination output.\n\n    Args:\n        level: Logging level (INFO, DEBUG, etc.)\n        json_format: Whether to output JSON (True) or Text (False).\n        service_name: Name of the service (added to JSON logs).\n        log_file: Optional file path to save logs.\n        console_options: Extra kwargs to pass to the console sink (e.g. {\"enqueue\": True}).\n        file_options: Configuration model (LogFileOptions) for file sink.\n    \"\"\"\n    # 1. Remove default handlers\n    logger.remove()\n\n    service = service_name\n\n    # 2. Configure Patcher (Trace ID injection)\n    def patcher(record):\n        request_id = get_request_id()\n        if request_id:\n            record[\"extra\"][\"request_id\"] = request_id\n        record[\"extra\"][\"service\"] = service\n\n    logger.configure(patcher=patcher)\n\n    # 3. Define Formatters\n    def _dev_formatter(record):\n        if \"request_id\" not in record[\"extra\"]:\n            record[\"extra\"][\"request_id\"] = \"-\"\n        return (\n            \"&lt;green&gt;{time:YYYYMMDD HH:mm:ss}&lt;/green&gt; \"\n            \"| {extra[service]} \"\n            \"| {extra[request_id]} \"\n            \"| {process.name} \"\n            \"| {thread.name} \"\n            \"| &lt;cyan&gt;{module}&lt;/cyan&gt;.&lt;cyan&gt;{function}&lt;/cyan&gt; \"\n            \"| &lt;level&gt;{level}&lt;/level&gt;: \"\n            \"&lt;level&gt;{message}&lt;/level&gt; \"\n            \"| {file.path}:{line}\\n\"\n        )\n\n    # 4. Prepare Console Config\n    c_config = console_options or {}\n    c_config.setdefault(\"level\", level)\n    c_config.setdefault(\"sink\", sys.stderr)\n    c_config.setdefault(\"enqueue\", True)  # Use thread-safe queue\n\n    if json_format:\n        c_config.setdefault(\"serialize\", True)\n    else:\n        c_config.setdefault(\"format\", _dev_formatter)\n\n    # Add Console Sink\n    logger.add(**c_config)\n\n    # 5. Prepare File Config (if enabled)\n    if log_file:\n        if file_options is None:\n            file_options = LogFileOptions()\n        f_config = file_options.model_dump()\n\n        # Ensure mandatory defaults\n        f_config.setdefault(\"sink\", log_file)\n        f_config.setdefault(\"level\", level)\n        f_config.setdefault(\"enqueue\", True)\n\n        if json_format:\n            f_config.setdefault(\"serialize\", True)\n        else:\n            f_config.setdefault(\"format\", _dev_formatter)\n\n        # Add File Sink\n        logger.add(**f_config)\n</code></pre>"},{"location":"api/middleware/","title":"Middleware Stack","text":"<p>ZodiacCore provides a standard stack of middlewares to handle cross-cutting concerns like request tracing, latency monitoring, and access logging.</p>"},{"location":"api/middleware/#1-core-middlewares","title":"1. Core Middlewares","text":""},{"location":"api/middleware/#trace-id-middleware","title":"Trace ID Middleware","text":"<p>The <code>TraceIDMiddleware</code> is the entry point for observability. It:</p> <ol> <li>Reads: Looks for an <code>X-Request-ID</code> header in the incoming request.</li> <li>Generates: If missing, it generates a fresh UUID.</li> <li>Persists: Sets the ID in the request context (via <code>zodiac_core.context</code>).</li> <li>Responds: Attaches the same ID to the response headers for frontend tracking.</li> </ol>"},{"location":"api/middleware/#access-log-middleware","title":"Access Log Middleware","text":"<p>The <code>AccessLogMiddleware</code> records every HTTP transaction. It logs:</p> <ul> <li>HTTP Method and Path.</li> <li>Status Code.</li> <li>Processing Latency (in milliseconds).</li> <li>The associated Trace ID (automatically picked up from the context).</li> </ul>"},{"location":"api/middleware/#2-usage-order","title":"2. Usage &amp; Order","text":"<p>The simplest way to use these is via <code>register_middleware</code>.</p> <p>Middleware Order</p> <p>ZodiacCore adds middlewares in a specific order to ensure that the Trace ID is generated before the Access Log tries to record it.</p> <pre><code>from fastapi import FastAPI\nfrom zodiac_core.middleware import register_middleware\n\napp = FastAPI()\n\n# Registers both TraceID and AccessLog middlewares in the correct order\nregister_middleware(app)\n</code></pre>"},{"location":"api/middleware/#3-customizing-trace-id-generation","title":"3. Customizing Trace ID Generation","text":"<p>If you want to use a custom header name or a different ID generator (e.g., K-Sorted IDs), you can add the middleware manually:</p> <pre><code>from zodiac_core.middleware import TraceIDMiddleware\n\napp.add_middleware(\n    TraceIDMiddleware,\n    header_name=\"X-Correlation-ID\",\n    generator=lambda: \"my-custom-id-123\"\n)\n</code></pre>"},{"location":"api/middleware/#4-api-reference","title":"4. API Reference","text":""},{"location":"api/middleware/#middleware-utilities","title":"Middleware Utilities","text":""},{"location":"api/middleware/#zodiac_core.middleware.TraceIDMiddleware","title":"<code>TraceIDMiddleware</code>","text":"<p>               Bases: <code>BaseHTTPMiddleware</code></p> <p>Loguru-compatible Trace ID Middleware.</p> <ol> <li>Extracts/Generates X-Request-ID.</li> <li>Sets it in a ContextVar (via zodiac_core.context).</li> <li>Appends it to the Response headers.</li> </ol> Source code in <code>zodiac_core/middleware.py</code> <pre><code>class TraceIDMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Loguru-compatible Trace ID Middleware.\n\n    1. Extracts/Generates X-Request-ID.\n    2. Sets it in a ContextVar (via zodiac_core.context).\n    3. Appends it to the Response headers.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: ASGIApp,\n        header_name: str = \"X-Request-ID\",\n        generator: Callable[[], str] = None,\n    ) -&gt; None:\n        super().__init__(app)\n        self.header_name = header_name\n        self.generator = generator or default_id_generator\n\n    async def dispatch(self, request: Request, call_next):\n        request_id = request.headers.get(self.header_name)\n        if request_id is None or len(request_id) != 36:\n            request_id = self.generator()\n\n        token = set_request_id(request_id)\n        try:\n            response = await call_next(request)\n            response.headers[self.header_name] = request_id\n            return response\n        finally:\n            reset_request_id(token)\n</code></pre>"},{"location":"api/middleware/#zodiac_core.middleware.AccessLogMiddleware","title":"<code>AccessLogMiddleware</code>","text":"<p>               Bases: <code>BaseHTTPMiddleware</code></p> <p>Standard Access Log Middleware.</p> <p>Logs request method, path, status code, and processing time (latency). Integrates with loguru (and will include request_id if TraceIDMiddleware is used).</p> Source code in <code>zodiac_core/middleware.py</code> <pre><code>class AccessLogMiddleware(BaseHTTPMiddleware):\n    \"\"\"\n    Standard Access Log Middleware.\n\n    Logs request method, path, status code, and processing time (latency).\n    Integrates with loguru (and will include request_id if TraceIDMiddleware is used).\n    \"\"\"\n\n    async def dispatch(self, request: Request, call_next):\n        start_time = time.perf_counter()\n        response = await call_next(request)\n        process_time = (time.perf_counter() - start_time) * 1000\n\n        logger.info(\n            \"{method} {path} - {status_code} - {latency:.2f}ms\",\n            method=request.method,\n            path=request.url.path,\n            status_code=response.status_code,\n            latency=process_time,\n        )\n\n        return response\n</code></pre>"},{"location":"api/middleware/#zodiac_core.middleware.register_middleware","title":"<code>register_middleware(app)</code>","text":"<p>Register standard Zodiac middleware stack.</p> <p>Ensures correct order: 1. TraceIDMiddleware (Outer layer: generates ID) 2. AccessLogMiddleware (Inner layer: logs with ID)</p> Source code in <code>zodiac_core/middleware.py</code> <pre><code>def register_middleware(app: ASGIApp):\n    \"\"\"\n    Register standard Zodiac middleware stack.\n\n    Ensures correct order:\n    1. TraceIDMiddleware (Outer layer: generates ID)\n    2. AccessLogMiddleware (Inner layer: logs with ID)\n    \"\"\"\n    # Middleware is added in LIFO order (Last added is the Outer-most layer)\n\n    # 2. Inner: Access Log\n    app.add_middleware(AccessLogMiddleware)\n\n    # 1. Outer: Trace ID\n    app.add_middleware(TraceIDMiddleware)\n</code></pre>"},{"location":"api/pagination/","title":"Standard Pagination","text":"<p>ZodiacCore provides a comprehensive pagination system that standardizes how your API handles list-based data. It includes request parameters, response models, and professional repository methods that automate pagination logic.</p>"},{"location":"api/pagination/#1-request-parameters","title":"1. Request Parameters","text":"<p>The <code>PageParams</code> model handles typical pagination query strings (<code>?page=1&amp;size=20</code>).</p> <pre><code>from typing import Annotated\nfrom fastapi import Depends\nfrom zodiac_core.pagination import PageParams\n\n@router.get(\"/items\")\nasync def list_items(\n    params: Annotated[PageParams, Depends()]\n):\n    # Automatically validated:\n    # params.page defaults to 1 (min 1)\n    # params.size defaults to 20 (max 100)\n    ...\n</code></pre> <p>Using Depends() vs Query()</p> <p>For Pydantic models like <code>PageParams</code>, use <code>Depends()</code> instead of <code>Query()</code>. FastAPI will automatically extract query parameters and validate them against the model.</p>"},{"location":"api/pagination/#2-standard-paged-response","title":"2. Standard Paged Response","text":"<p>The <code>PagedResponse[T]</code> is a generic model that wraps your data items along with metadata.</p>"},{"location":"api/pagination/#the-response-structure","title":"The Response Structure","text":"<pre><code>{\n  \"code\": 0,\n  \"message\": \"Success\",\n  \"data\": {\n    \"items\": [...],\n    \"total\": 100,\n    \"page\": 1,\n    \"size\": 20\n  }\n}\n</code></pre>"},{"location":"api/pagination/#building-the-response","title":"Building the Response","text":"<p>Use the <code>.create()</code> factory method to easily build the response from your query results and the input <code>PageParams</code>.</p> <pre><code>from zodiac_core.pagination import PagedResponse\n\nreturn PagedResponse.create(\n    items=items,\n    total=total_count,\n    params=page_params\n)\n</code></pre>"},{"location":"api/pagination/#3-professional-pagination-with-basesqlrepository","title":"3. Professional Pagination with BaseSQLRepository","text":"<p>For database queries, <code>BaseSQLRepository</code> provides two methods that automate pagination:</p>"},{"location":"api/pagination/#paginate_query-recommended-for-most-cases","title":"<code>paginate_query()</code> - Recommended for Most Cases","text":"<p>This is the convenience method that automatically manages the database session. Use this in your repository methods:</p> <pre><code>from sqlalchemy import select\nfrom zodiac_core.db.repository import BaseSQLRepository\nfrom zodiac_core.pagination import PagedResponse, PageParams\n\nclass ItemRepository(BaseSQLRepository):\n    async def list_items(self, params: PageParams) -&gt; PagedResponse[ItemModel]:\n        \"\"\"List items with pagination.\"\"\"\n        stmt = select(ItemModel).order_by(ItemModel.id)\n        return await self.paginate_query(stmt, params)\n</code></pre> <p>What it does:</p> <ul> <li>\u2705 Automatically manages database session</li> <li>\u2705 Calculates total count (handles complex queries with joins/groups)</li> <li>\u2705 Applies limit/offset</li> <li>\u2705 Packages results into <code>PagedResponse</code></li> </ul> <p>When to use: - Most repository methods that need pagination - Simple queries that don't require custom session management</p>"},{"location":"api/pagination/#paginate-for-advanced-use-cases","title":"<code>paginate()</code> - For Advanced Use Cases","text":"<p>This method requires you to manage the session yourself. Use this when you need more control:</p> <pre><code>async def list_items_with_custom_logic(self, params: PageParams) -&gt; PagedResponse[ItemModel]:\n    \"\"\"Example with custom session management.\"\"\"\n    async with self.session() as session:\n        # You can add custom logic here (e.g., filtering, joins)\n        stmt = select(ItemModel).where(ItemModel.status == \"active\")\n        stmt = stmt.order_by(ItemModel.created_at.desc())\n\n        return await self.paginate(session, stmt, params)\n</code></pre> <p>What it does:</p> <ul> <li>\u2705 Calculates total count (handles complex queries)</li> <li>\u2705 Applies limit/offset</li> <li>\u2705 Packages results into <code>PagedResponse</code></li> <li>\u26a0\ufe0f Requires you to provide an active session</li> </ul> <p>When to use:</p> <ul> <li>When you need custom session management</li> <li>When you want to perform multiple operations in a single transaction</li> <li>When you need to add complex query logic before pagination</li> </ul>"},{"location":"api/pagination/#how-count-calculation-works","title":"How Count Calculation Works","text":"<p>Both methods handle complex queries correctly:</p> <ul> <li>Simple queries: <code>SELECT COUNT(*) FROM (SELECT ...)</code></li> <li>Queries with joins: Automatically wraps in subquery</li> <li>Queries with GROUP BY: Handles correctly</li> <li>Queries with ORDER BY: Removed from count query (as expected)</li> </ul> <p>The implementation removes <code>limit</code>/<code>offset</code> before counting and safely wraps complex queries in subqueries.</p>"},{"location":"api/pagination/#transformation-support","title":"Transformation Support","text":"<p>Both methods support optional transformation to Pydantic models:</p> <pre><code>from app.api.schemas.item_schema import ItemSchema\n\n# Transform DB models to response schemas\nreturn await self.paginate_query(stmt, params, transformer=ItemSchema)\n</code></pre>"},{"location":"api/pagination/#4-complete-example","title":"4. Complete Example","text":"<p>Here's a complete example showing the full flow:</p> <p>Repository: <pre><code>class ItemRepository(BaseSQLRepository):\n    async def list_items(self, params: PageParams) -&gt; PagedResponse[ItemModel]:\n        stmt = select(ItemModel).order_by(ItemModel.id)\n        return await self.paginate_query(stmt, params)\n</code></pre></p> <p>Service: <pre><code>class ItemService:\n    def __init__(self, item_repo: ItemRepository) -&gt; None:\n        self.item_repo = item_repo\n\n    async def list_items(self, page_params: PageParams) -&gt; PagedResponse[ItemModel]:\n        return await self.item_repo.list_items(page_params)\n</code></pre></p> <p>Router: <pre><code>@router.get(\"\", response_model=PagedResponse[ItemSchema])\n@inject\nasync def list_items(\n    page_params: Annotated[PageParams, Depends()],\n    service: Annotated[ItemService, Depends(Provide[Container.item_service])],\n):\n    return await service.list_items(page_params)\n</code></pre></p> <p>No manual calculations needed! The <code>paginate_query</code> method handles everything.</p>"},{"location":"api/pagination/#5-api-reference","title":"5. API Reference","text":""},{"location":"api/pagination/#pagination-models","title":"Pagination Models","text":""},{"location":"api/pagination/#zodiac_core.pagination.PageParams","title":"<code>PageParams</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Standard pagination query parameters.</p> Usage <pre><code>from typing import Annotated\nfrom fastapi import Query\nfrom zodiac_core.pagination import PageParams\n\n@app.get(\"/users\")\ndef list_users(page_params: Annotated[PageParams, Query()]):\n    skip = (page_params.page - 1) * page_params.size\n    limit = page_params.size\n    ...\n</code></pre> Source code in <code>zodiac_core/pagination.py</code> <pre><code>class PageParams(BaseModel):\n    \"\"\"\n    Standard pagination query parameters.\n\n    Usage:\n        ```python\n        from typing import Annotated\n        from fastapi import Query\n        from zodiac_core.pagination import PageParams\n\n        @app.get(\"/users\")\n        def list_users(page_params: Annotated[PageParams, Query()]):\n            skip = (page_params.page - 1) * page_params.size\n            limit = page_params.size\n            ...\n        ```\n    \"\"\"\n\n    page: int = Field(1, ge=1, description=\"Page number (1-based)\")\n    size: int = Field(20, ge=1, le=100, description=\"Page size\")\n</code></pre>"},{"location":"api/pagination/#zodiac_core.pagination.PagedResponse","title":"<code>PagedResponse</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>Standard generic paginated response model.</p> Usage <pre><code>from typing import Annotated\nfrom fastapi import Query\nfrom zodiac_core.pagination import PagedResponse, PageParams\n\n@app.get(\"/users\", response_model=PagedResponse[UserSchema])\ndef list_users(page_params: Annotated[PageParams, Query()]):\n    users, total_count = db.find_users(...)\n    return PagedResponse.create(users, total_count, page_params)\n</code></pre> Source code in <code>zodiac_core/pagination.py</code> <pre><code>class PagedResponse(BaseModel, Generic[T]):\n    \"\"\"\n    Standard generic paginated response model.\n\n    Usage:\n        ```python\n        from typing import Annotated\n        from fastapi import Query\n        from zodiac_core.pagination import PagedResponse, PageParams\n\n        @app.get(\"/users\", response_model=PagedResponse[UserSchema])\n        def list_users(page_params: Annotated[PageParams, Query()]):\n            users, total_count = db.find_users(...)\n            return PagedResponse.create(users, total_count, page_params)\n        ```\n    \"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    items: List[T] = Field(description=\"List of items for the current page\")\n    total: int = Field(description=\"Total number of items\")\n    page: int = Field(description=\"Current page number\")\n    size: int = Field(description=\"Current page size\")\n\n    @classmethod\n    def create(\n        cls,\n        items: List[T],\n        total: int,\n        params: PageParams,\n    ) -&gt; \"PagedResponse[T]\":\n        \"\"\"\n        Factory method to create a PagedResponse from items, total count, and PageParams.\n\n        Args:\n            items: The list of data objects (Pydantic models or dicts).\n            total: The total number of records in the database matching the query.\n            params: The PageParams object from the request.\n        \"\"\"\n        return cls(\n            items=items,\n            total=total,\n            page=params.page,\n            size=params.size,\n        )\n</code></pre>"},{"location":"api/pagination/#zodiac_core.pagination.PagedResponse.create","title":"<code>create(items, total, params)</code>  <code>classmethod</code>","text":"<p>Factory method to create a PagedResponse from items, total count, and PageParams.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>List[T]</code> <p>The list of data objects (Pydantic models or dicts).</p> required <code>total</code> <code>int</code> <p>The total number of records in the database matching the query.</p> required <code>params</code> <code>PageParams</code> <p>The PageParams object from the request.</p> required Source code in <code>zodiac_core/pagination.py</code> <pre><code>@classmethod\ndef create(\n    cls,\n    items: List[T],\n    total: int,\n    params: PageParams,\n) -&gt; \"PagedResponse[T]\":\n    \"\"\"\n    Factory method to create a PagedResponse from items, total count, and PageParams.\n\n    Args:\n        items: The list of data objects (Pydantic models or dicts).\n        total: The total number of records in the database matching the query.\n        params: The PageParams object from the request.\n    \"\"\"\n    return cls(\n        items=items,\n        total=total,\n        page=params.page,\n        size=params.size,\n    )\n</code></pre>"},{"location":"api/pagination/#repository-methods","title":"Repository Methods","text":"<p>Standard base class for SQL-based repositories.</p> <p>Supports multiple database instances via <code>db_name</code> and provides professional utilities for common operations like pagination.</p> Source code in <code>zodiac_core/db/repository.py</code> <pre><code>class BaseSQLRepository:\n    \"\"\"\n    Standard base class for SQL-based repositories.\n\n    Supports multiple database instances via `db_name` and provides\n    professional utilities for common operations like pagination.\n    \"\"\"\n\n    def __init__(\n        self,\n        session_factory: Optional[async_sessionmaker[AsyncSession]] = None,\n        db_name: str = DEFAULT_DB_NAME,\n        options: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"\n        Initialize the repository.\n\n        Args:\n            session_factory: Optional custom session factory. If provided, db_name is ignored.\n            db_name: The name of the database engine registered in db.setup(). Defaults to DEFAULT_DB_NAME (\"default\").\n            options: Optional configuration/options for the repository.\n        \"\"\"\n        self._session_factory = session_factory\n        self.db_name = db_name\n        self.options = options\n\n    @asynccontextmanager\n    async def session(self) -&gt; AsyncIterator[AsyncSession]:\n        \"\"\"\n        Async context manager for obtaining a database session.\n        Uses the injected factory or resolves one from the global 'db' via 'db_name'.\n\n        Note:\n            This context manager does NOT auto-commit. You must explicitly call\n            `await session.commit()` to persist changes to the database.\n        \"\"\"\n        factory = self._session_factory or db.get_factory(self.db_name)\n        async with manage_session(factory) as session:\n            yield session\n\n    async def paginate(\n        self,\n        session: AsyncSession,\n        statement: Any,\n        params: PageParams,\n        transformer: Optional[Type[T]] = None,\n    ) -&gt; PagedResponse[T]:\n        \"\"\"\n        Execute a paginated query with automatic count and paging.\n\n        Performs:\n        1. Automatic total count query using the provided statement.\n        2. Automatic limit/offset application.\n        3. Packaging results into a standardized PagedResponse.\n\n        Args:\n            session: The active AsyncSession.\n            statement: The SQLAlchemy select statement (without limit/offset).\n            params: Standard PageParams (page, size).\n            transformer: Optional Pydantic model to transform DB objects into.\n\n        Example:\n            ```python\n            async with self.session() as session:\n                stmt = select(UserModel).order_by(UserModel.created_at.desc())\n                return await self.paginate(session, stmt, params)\n            ```\n        \"\"\"\n        # 1. Execute Count Query\n        # Remove limit/offset (if any) for count query, then wrap in subquery\n        # subquery() handles order_by correctly, and wrapping in subquery handles complex queries (joins, groups)\n        count_base = statement.limit(None).offset(None)\n        count_stmt = select(func.count()).select_from(count_base.subquery())\n        total = (await session.execute(count_stmt)).scalar() or 0\n\n        # 2. Execute Paged Query\n        skip = (params.page - 1) * params.size\n        paged_stmt = statement.offset(skip).limit(params.size)\n        result = await session.execute(paged_stmt)\n        items = result.scalars().all()\n\n        # 3. Optional Transformation\n        if transformer:\n            items = [transformer.model_validate(item) for item in items]\n\n        return PagedResponse.create(items=list(items), total=total, params=params)\n\n    async def paginate_query(\n        self,\n        statement: Any,\n        params: PageParams,\n        transformer: Optional[Type[T]] = None,\n    ) -&gt; PagedResponse[T]:\n        \"\"\"\n        Convenience method that automatically manages session for pagination.\n\n        This is a wrapper around `paginate()` that handles session management,\n        making it easier to use in repository methods.\n\n        Args:\n            statement: The SQLAlchemy select statement (without limit/offset).\n            params: Standard PageParams (page, size).\n            transformer: Optional Pydantic model to transform DB objects into.\n\n        Example:\n            ```python\n            async def list_items(self, params: PageParams) -&gt; PagedResponse[ItemModel]:\n                stmt = select(ItemModel).order_by(ItemModel.id)\n                return await self.paginate_query(stmt, params)\n            ```\n        \"\"\"\n        async with self.session() as session:\n            return await self.paginate(session, statement, params, transformer)\n</code></pre>"},{"location":"api/pagination/#zodiac_core.db.repository.BaseSQLRepository.paginate","title":"<code>paginate(session, statement, params, transformer=None)</code>  <code>async</code>","text":"<p>Execute a paginated query with automatic count and paging.</p> <p>Performs: 1. Automatic total count query using the provided statement. 2. Automatic limit/offset application. 3. Packaging results into a standardized PagedResponse.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>AsyncSession</code> <p>The active AsyncSession.</p> required <code>statement</code> <code>Any</code> <p>The SQLAlchemy select statement (without limit/offset).</p> required <code>params</code> <code>PageParams</code> <p>Standard PageParams (page, size).</p> required <code>transformer</code> <code>Optional[Type[T]]</code> <p>Optional Pydantic model to transform DB objects into.</p> <code>None</code> Example <pre><code>async with self.session() as session:\n    stmt = select(UserModel).order_by(UserModel.created_at.desc())\n    return await self.paginate(session, stmt, params)\n</code></pre> Source code in <code>zodiac_core/db/repository.py</code> <pre><code>async def paginate(\n    self,\n    session: AsyncSession,\n    statement: Any,\n    params: PageParams,\n    transformer: Optional[Type[T]] = None,\n) -&gt; PagedResponse[T]:\n    \"\"\"\n    Execute a paginated query with automatic count and paging.\n\n    Performs:\n    1. Automatic total count query using the provided statement.\n    2. Automatic limit/offset application.\n    3. Packaging results into a standardized PagedResponse.\n\n    Args:\n        session: The active AsyncSession.\n        statement: The SQLAlchemy select statement (without limit/offset).\n        params: Standard PageParams (page, size).\n        transformer: Optional Pydantic model to transform DB objects into.\n\n    Example:\n        ```python\n        async with self.session() as session:\n            stmt = select(UserModel).order_by(UserModel.created_at.desc())\n            return await self.paginate(session, stmt, params)\n        ```\n    \"\"\"\n    # 1. Execute Count Query\n    # Remove limit/offset (if any) for count query, then wrap in subquery\n    # subquery() handles order_by correctly, and wrapping in subquery handles complex queries (joins, groups)\n    count_base = statement.limit(None).offset(None)\n    count_stmt = select(func.count()).select_from(count_base.subquery())\n    total = (await session.execute(count_stmt)).scalar() or 0\n\n    # 2. Execute Paged Query\n    skip = (params.page - 1) * params.size\n    paged_stmt = statement.offset(skip).limit(params.size)\n    result = await session.execute(paged_stmt)\n    items = result.scalars().all()\n\n    # 3. Optional Transformation\n    if transformer:\n        items = [transformer.model_validate(item) for item in items]\n\n    return PagedResponse.create(items=list(items), total=total, params=params)\n</code></pre>"},{"location":"api/pagination/#zodiac_core.db.repository.BaseSQLRepository.paginate_query","title":"<code>paginate_query(statement, params, transformer=None)</code>  <code>async</code>","text":"<p>Convenience method that automatically manages session for pagination.</p> <p>This is a wrapper around <code>paginate()</code> that handles session management, making it easier to use in repository methods.</p> <p>Parameters:</p> Name Type Description Default <code>statement</code> <code>Any</code> <p>The SQLAlchemy select statement (without limit/offset).</p> required <code>params</code> <code>PageParams</code> <p>Standard PageParams (page, size).</p> required <code>transformer</code> <code>Optional[Type[T]]</code> <p>Optional Pydantic model to transform DB objects into.</p> <code>None</code> Example <pre><code>async def list_items(self, params: PageParams) -&gt; PagedResponse[ItemModel]:\n    stmt = select(ItemModel).order_by(ItemModel.id)\n    return await self.paginate_query(stmt, params)\n</code></pre> Source code in <code>zodiac_core/db/repository.py</code> <pre><code>async def paginate_query(\n    self,\n    statement: Any,\n    params: PageParams,\n    transformer: Optional[Type[T]] = None,\n) -&gt; PagedResponse[T]:\n    \"\"\"\n    Convenience method that automatically manages session for pagination.\n\n    This is a wrapper around `paginate()` that handles session management,\n    making it easier to use in repository methods.\n\n    Args:\n        statement: The SQLAlchemy select statement (without limit/offset).\n        params: Standard PageParams (page, size).\n        transformer: Optional Pydantic model to transform DB objects into.\n\n    Example:\n        ```python\n        async def list_items(self, params: PageParams) -&gt; PagedResponse[ItemModel]:\n            stmt = select(ItemModel).order_by(ItemModel.id)\n            return await self.paginate_query(stmt, params)\n        ```\n    \"\"\"\n    async with self.session() as session:\n        return await self.paginate(session, statement, params, transformer)\n</code></pre>"},{"location":"api/routing/","title":"Routing &amp; Response Wrapping","text":"<p>ZodiacCore enhances FastAPI's routing system to provide automatic response standardization. By using <code>APIRouter</code>, you ensure that every endpoint returns a consistent JSON structure without manual boilerplate.</p>"},{"location":"api/routing/#1-the-zodiac-apirouter","title":"1. The Zodiac APIRouter","text":"<p>The <code>APIRouter</code> in ZodiacCore is a drop-in replacement for <code>fastapi.APIRouter</code>. It uses a custom <code>ZodiacRoute</code> class that intercepts outgoing data and wraps it.</p>"},{"location":"api/routing/#automatic-wrapping","title":"Automatic Wrapping","text":"<p>When you return a dictionary, a Pydantic model, or a list from your route, Zodiac automatically wraps it in a <code>Response</code> model:</p> <pre><code>from zodiac_core.routing import APIRouter\n\nrouter = APIRouter()\n\n@router.get(\"/status\")\nasync def get_status():\n    return {\"status\": \"online\"}\n</code></pre> <p>Resulting JSON: <pre><code>{\n  \"code\": 0,\n  \"message\": \"Success\",\n  \"data\": {\n    \"status\": \"online\"\n  }\n}\n</code></pre></p>"},{"location":"api/routing/#2-standard-response-structure","title":"2. Standard Response Structure","text":"<p>All Zodiac responses follow this schema:</p> Field Type Description <code>code</code> <code>int</code> Business status code (0 for success). <code>message</code> <code>string</code> A brief description of the result. <code>data</code> <code>any</code> The actual payload (result of your function)."},{"location":"api/routing/#manual-responses","title":"Manual Responses","text":"<p>If you need to return a non-standard response (e.g., a FileResponse or a custom status code), you can still return raw FastAPI <code>Response</code> objects or Zodiac's <code>Response</code> class. If the return type is already a <code>Response</code>, Zodiac will not wrap it again.</p> <pre><code>from zodiac_core.response import response_ok\n\n@router.get(\"/custom\")\nasync def manual():\n    return response_ok(message=\"Custom success\", data={\"id\": 1})\n</code></pre>"},{"location":"api/routing/#3-openapi-integration","title":"3. OpenAPI Integration","text":"<p>ZodiacCore's <code>APIRouter</code> dynamically generates Pydantic models for your responses. This means your Swagger UI (<code>/docs</code>) will correctly display the wrapped structure, including the <code>code</code>, <code>message</code>, and <code>data</code> fields, mapped to your specific return type.</p>"},{"location":"api/routing/#4-api-reference","title":"4. API Reference","text":""},{"location":"api/routing/#routing-utilities","title":"Routing Utilities","text":""},{"location":"api/routing/#zodiac_core.routing.APIRouter","title":"<code>APIRouter</code>","text":"<p>               Bases: <code>APIRouter</code></p> <p>Zodiac-enhanced APIRouter that uses ZodiacRoute by default.</p> <p>All routes registered via this router will automatically: - Wrap response_model with Response[T] for OpenAPI docs - Wrap endpoint return values with Response structure</p> Source code in <code>zodiac_core/routing.py</code> <pre><code>class APIRouter(FastAPIRouter):\n    \"\"\"\n    Zodiac-enhanced APIRouter that uses ZodiacRoute by default.\n\n    All routes registered via this router will automatically:\n    - Wrap response_model with Response[T] for OpenAPI docs\n    - Wrap endpoint return values with Response structure\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        kwargs.setdefault(\"route_class\", ZodiacRoute)\n        super().__init__(*args, **kwargs)\n</code></pre>"},{"location":"api/routing/#zodiac_core.routing.ZodiacRoute","title":"<code>ZodiacRoute</code>","text":"<p>               Bases: <code>APIRoute</code></p> <p>Custom APIRoute that automatically wraps response models and endpoint returns with the standard Response[T] structure.</p> Source code in <code>zodiac_core/routing.py</code> <pre><code>class ZodiacRoute(APIRoute):\n    \"\"\"\n    Custom APIRoute that automatically wraps response models and endpoint returns\n    with the standard Response[T] structure.\n    \"\"\"\n\n    def __init__(\n        self,\n        path: str,\n        endpoint: Callable[..., Any],\n        *,\n        response_model: Any = None,\n        responses: Optional[Dict[Union[int, str], Dict[str, Any]]] = None,\n        **kwargs,\n    ) -&gt; None:\n        # Resolve FastAPI's DefaultPlaceholder\n        if isinstance(response_model, DefaultPlaceholder):\n            response_model = response_model.value\n\n        # 1. Wrap main response model (default to Any if missing)\n        if self._should_wrap(response_model):\n            response_model = self._wrap_response_model(response_model or Any)\n\n        # 2. Wrap additional responses (e.g. 400, 404 models)\n        # Copy to avoid mutating caller's dict\n        if responses:\n            responses = {code: {**res_dict} for code, res_dict in responses.items()}\n            for res in responses.values():\n                if \"model\" in res and self._should_wrap(res[\"model\"]):\n                    res[\"model\"] = self._wrap_response_model(res[\"model\"])\n\n        # 3. Wrap endpoint to auto-wrap return values\n        endpoint = self._wrap_endpoint(endpoint)\n\n        super().__init__(\n            path,\n            endpoint,\n            response_model=response_model,\n            responses=responses,\n            **kwargs,\n        )\n\n    @staticmethod\n    def _should_wrap(model: Any) -&gt; bool:\n        \"\"\"Check if a model needs to be wrapped with Response[T].\"\"\"\n        if model is Any or model is None:\n            return True\n        origin = get_origin(model)\n        if origin is Response:\n            return False\n        try:\n            if isinstance(model, type) and issubclass(model, Response):\n                return False\n        except TypeError:\n            pass\n        return True\n\n    @staticmethod\n    def _wrap_response_model(model: Any) -&gt; type[Response]:\n        \"\"\"Wrap a model type with Response[T] using Pydantic's native generics.\"\"\"\n        return Response[model]\n\n    @staticmethod\n    def _maybe_wrap_result(result: Any) -&gt; Any:\n        \"\"\"Wrap result in Response if not already a Response type.\"\"\"\n        if isinstance(result, (Response, FastAPIResponse)):\n            return result\n        return Response(data=result)\n\n    @staticmethod\n    def _wrap_endpoint(endpoint: Callable) -&gt; Callable:\n        \"\"\"Wrap endpoint to automatically wrap return values in Response.\"\"\"\n\n        @wraps(endpoint)\n        async def async_wrapper(*args, **kwargs):\n            result = await endpoint(*args, **kwargs)\n            return ZodiacRoute._maybe_wrap_result(result)\n\n        @wraps(endpoint)\n        def sync_wrapper(*args, **kwargs):\n            result = endpoint(*args, **kwargs)\n            return ZodiacRoute._maybe_wrap_result(result)\n\n        return async_wrapper if inspect.iscoroutinefunction(endpoint) else sync_wrapper\n</code></pre>"},{"location":"api/routing/#response-helpers","title":"Response Helpers","text":""},{"location":"api/routing/#zodiac_core.response.Response","title":"<code>Response</code>","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[T]</code></p> <p>Standard API response model.</p> Source code in <code>zodiac_core/response.py</code> <pre><code>class Response(BaseModel, Generic[T]):\n    \"\"\"Standard API response model.\"\"\"\n\n    model_config = ConfigDict(populate_by_name=True)\n\n    code: int = Field(default=0, description=\"Business status code\")\n    data: Optional[T] = Field(default=None, description=\"Response payload\")\n    message: str = Field(default=\"Success\", description=\"Response message\")\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.create_response","title":"<code>create_response(http_code, code=None, data=None, message='')</code>","text":"<p>Create a standardized JSON response.</p> <p>Parameters:</p> Name Type Description Default <code>http_code</code> <code>int</code> <p>HTTP status code</p> required <code>code</code> <code>Optional[int]</code> <p>Business status code (defaults to http_code if not provided)</p> <code>None</code> <code>data</code> <code>Any</code> <p>Response payload</p> <code>None</code> <code>message</code> <code>str</code> <p>Response message</p> <code>''</code> Source code in <code>zodiac_core/response.py</code> <pre><code>def create_response(\n    http_code: int,\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"\",\n) -&gt; JSONResponse:\n    \"\"\"\n    Create a standardized JSON response.\n\n    Args:\n        http_code: HTTP status code\n        code: Business status code (defaults to http_code if not provided)\n        data: Response payload\n        message: Response message\n    \"\"\"\n    if code is None:\n        code = http_code\n\n    response = Response(code=code, data=data, message=message)\n    return JSONResponse(\n        status_code=http_code,\n        content=response.model_dump(mode=\"json\"),\n    )\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_ok","title":"<code>response_ok(code=None, data=None, message='Success')</code>","text":"<p>Create a successful response (200 OK)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_ok(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Success\",\n) -&gt; JSONResponse:\n    \"\"\"Create a successful response (200 OK)\"\"\"\n    return create_response(status.HTTP_200_OK, code=code if code is not None else 0, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_created","title":"<code>response_created(code=None, data=None, message='Created')</code>","text":"<p>Create a resource created response (201 Created)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_created(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Created\",\n) -&gt; JSONResponse:\n    \"\"\"Create a resource created response (201 Created)\"\"\"\n    return create_response(status.HTTP_201_CREATED, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_bad_request","title":"<code>response_bad_request(code=None, data=None, message='Bad Request')</code>","text":"<p>Create a bad request error response (400 Bad Request)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_bad_request(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Bad Request\",\n) -&gt; JSONResponse:\n    \"\"\"Create a bad request error response (400 Bad Request)\"\"\"\n    return create_response(status.HTTP_400_BAD_REQUEST, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_unauthorized","title":"<code>response_unauthorized(code=None, data=None, message='Unauthorized')</code>","text":"<p>Create an unauthorized response (401 Unauthorized)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_unauthorized(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Unauthorized\",\n) -&gt; JSONResponse:\n    \"\"\"Create an unauthorized response (401 Unauthorized)\"\"\"\n    return create_response(status.HTTP_401_UNAUTHORIZED, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_forbidden","title":"<code>response_forbidden(code=None, data=None, message='Forbidden')</code>","text":"<p>Create a forbidden response (403 Forbidden)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_forbidden(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Forbidden\",\n) -&gt; JSONResponse:\n    \"\"\"Create a forbidden response (403 Forbidden)\"\"\"\n    return create_response(status.HTTP_403_FORBIDDEN, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_not_found","title":"<code>response_not_found(code=None, data=None, message='Not Found')</code>","text":"<p>Create a not found response (404 Not Found)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_not_found(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Not Found\",\n) -&gt; JSONResponse:\n    \"\"\"Create a not found response (404 Not Found)\"\"\"\n    return create_response(status.HTTP_404_NOT_FOUND, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_conflict","title":"<code>response_conflict(code=None, data=None, message='Conflict')</code>","text":"<p>Create a conflict response (409 Conflict)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_conflict(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Conflict\",\n) -&gt; JSONResponse:\n    \"\"\"Create a conflict response (409 Conflict)\"\"\"\n    return create_response(status.HTTP_409_CONFLICT, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_unprocessable_entity","title":"<code>response_unprocessable_entity(code=None, data=None, message='Unprocessable Entity')</code>","text":"<p>Create an unprocessable entity response (422 Unprocessable Entity)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_unprocessable_entity(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Unprocessable Entity\",\n) -&gt; JSONResponse:\n    \"\"\"Create an unprocessable entity response (422 Unprocessable Entity)\"\"\"\n    return create_response(status.HTTP_422_UNPROCESSABLE_ENTITY, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/routing/#zodiac_core.response.response_server_error","title":"<code>response_server_error(code=None, data=None, message='Internal Server Error')</code>","text":"<p>Create a server error response (500 Internal Server Error)</p> Source code in <code>zodiac_core/response.py</code> <pre><code>def response_server_error(\n    code: Optional[int] = None,\n    data: Any = None,\n    message: str = \"Internal Server Error\",\n) -&gt; JSONResponse:\n    \"\"\"Create a server error response (500 Internal Server Error)\"\"\"\n    return create_response(status.HTTP_500_INTERNAL_SERVER_ERROR, code=code, data=data, message=message)\n</code></pre>"},{"location":"api/schemas/","title":"Data Schemas (DTOs)","text":"<p>ZodiacCore provides a set of base Pydantic models and types to standardize Data Transfer Objects (DTOs). These mirror our database models to ensure end-to-end consistency.</p>"},{"location":"api/schemas/#1-core-models","title":"1. Core Models","text":""},{"location":"api/schemas/#coremodel","title":"CoreModel","text":"<p>The <code>CoreModel</code> is the recommended base class for all your Pydantic models. It comes pre-configured with: - <code>from_attributes=True</code>: Allows easy conversion from ORM objects (like SQLModel or SQLAlchemy) using <code>Model.model_validate(orm_obj)</code>.</p> <pre><code>from zodiac_core import CoreModel\n\nclass UserSchema(CoreModel):\n    username: str\n    email: str\n</code></pre>"},{"location":"api/schemas/#2-standard-schema-mixins","title":"2. Standard Schema Mixins","text":"<p>We provide several mixins to match the <code>IntIDModel</code> and <code>UUIDModel</code> found in the database layer.</p> Schema Primary Key Timestamps <code>IntIDSchema</code> <code>id: int</code> <code>created_at</code>, <code>updated_at</code> <code>UUIDSchema</code> <code>id: UUID</code> <code>created_at</code>, <code>updated_at</code>"},{"location":"api/schemas/#example-usage","title":"Example Usage","text":"<pre><code>from zodiac_core import IntIDSchema\n\nclass ProductRead(IntIDSchema):\n    name: str\n    price: float\n</code></pre>"},{"location":"api/schemas/#3-utc-datetime-utility","title":"3. UTC Datetime Utility","text":"<p>Handling timezones correctly is notoriously difficult. ZodiacCore includes a <code>UtcDatetime</code> type that automatically converts incoming datetime objects to UTC and ensures they are timezone-aware.</p> <pre><code>from zodiac_core import UtcDatetime\nfrom pydantic import BaseModel\n\nclass Event(BaseModel):\n    # Any incoming datetime will be converted to aware-UTC\n    happened_at: UtcDatetime\n</code></pre>"},{"location":"api/schemas/#4-api-reference","title":"4. API Reference","text":""},{"location":"api/schemas/#base-schemas","title":"Base Schemas","text":""},{"location":"api/schemas/#zodiac_core.schemas.UtcDatetime","title":"<code>UtcDatetime = Annotated[datetime, BeforeValidator(ensure_utc)]</code>  <code>module-attribute</code>","text":""},{"location":"api/schemas/#zodiac_core.schemas.CoreModel","title":"<code>CoreModel</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base Pydantic model for all Zodiac schemas (DTOs).</p> <p>Features: - Standard snake_case fields - From attributes enabled (ORM mode)</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class CoreModel(BaseModel):\n    \"\"\"\n    Base Pydantic model for all Zodiac schemas (DTOs).\n\n    Features:\n    - Standard snake_case fields\n    - From attributes enabled (ORM mode)\n    \"\"\"\n\n    model_config = ConfigDict(\n        from_attributes=True,\n    )\n</code></pre>"},{"location":"api/schemas/#zodiac_core.schemas.IntIDSchema","title":"<code>IntIDSchema</code>","text":"<p>               Bases: <code>CoreModel</code>, <code>IntIDSchemaMixin</code>, <code>DateTimeSchemaMixin</code></p> <p>Base schema for models with an Integer ID and Timestamps. Includes: Core Config + ID + CreatedAt + UpdatedAt.</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class IntIDSchema(CoreModel, IntIDSchemaMixin, DateTimeSchemaMixin):\n    \"\"\"\n    Base schema for models with an Integer ID and Timestamps.\n    Includes: Core Config + ID + CreatedAt + UpdatedAt.\n    \"\"\"\n</code></pre>"},{"location":"api/schemas/#zodiac_core.schemas.UUIDSchema","title":"<code>UUIDSchema</code>","text":"<p>               Bases: <code>CoreModel</code>, <code>UUIDSchemaMixin</code>, <code>DateTimeSchemaMixin</code></p> <p>Base schema for models with a UUID and Timestamps. Includes: Core Config + ID + CreatedAt + UpdatedAt.</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class UUIDSchema(CoreModel, UUIDSchemaMixin, DateTimeSchemaMixin):\n    \"\"\"\n    Base schema for models with a UUID and Timestamps.\n    Includes: Core Config + ID + CreatedAt + UpdatedAt.\n    \"\"\"\n</code></pre>"},{"location":"api/schemas/#zodiac_core.schemas.IntIDSchemaMixin","title":"<code>IntIDSchemaMixin</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include an integer ID.</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class IntIDSchemaMixin(BaseModel):\n    \"\"\"Mixin for models that include an integer ID.\"\"\"\n\n    id: int = Field(\n        ...,\n        description=\"The unique integer identifier.\",\n    )\n</code></pre>"},{"location":"api/schemas/#zodiac_core.schemas.UUIDSchemaMixin","title":"<code>UUIDSchemaMixin</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include a UUID.</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class UUIDSchemaMixin(BaseModel):\n    \"\"\"Mixin for models that include a UUID.\"\"\"\n\n    id: UUID = Field(\n        ...,\n        description=\"The unique UUID identifier.\",\n    )\n</code></pre>"},{"location":"api/schemas/#zodiac_core.schemas.DateTimeSchemaMixin","title":"<code>DateTimeSchemaMixin</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Mixin for models that include standard timestamps.</p> Source code in <code>zodiac_core/schemas.py</code> <pre><code>class DateTimeSchemaMixin(BaseModel):\n    \"\"\"Mixin for models that include standard timestamps.\"\"\"\n\n    created_at: UtcDatetime = Field(\n        ...,\n        description=\"The UTC timestamp when the record was created.\",\n    )\n    updated_at: UtcDatetime = Field(\n        ...,\n        description=\"The UTC timestamp when the record was last updated.\",\n    )\n</code></pre>"},{"location":"user-guide/architecture/","title":"Architecture Guide","text":"<p>This guide explains the Layered Architecture with Dependency Injection that ZodiacCore promotes for building maintainable, testable, and scalable FastAPI applications.</p> <p>ZodiacCore recommends a 3-tier architecture as the standard approach, but you can adapt it to your project's needs. This guide focuses on the 3-tier structure while also mentioning how to extend it to a 4-tier architecture when needed.</p>"},{"location":"user-guide/architecture/#why-this-architecture","title":"Why This Architecture?","text":"<p>The layered architecture with DI provides:</p> <ul> <li>\u2705 Separation of Concerns: Each layer has a clear responsibility</li> <li>\u2705 Testability: Easy to mock dependencies and test in isolation</li> <li>\u2705 Maintainability: Changes in one layer don't cascade to others</li> <li>\u2705 Scalability: Easy to swap implementations (e.g., different databases)</li> <li>\u2705 Team Collaboration: Clear boundaries for parallel development</li> </ul>"},{"location":"user-guide/architecture/#architecture-layers","title":"Architecture Layers","text":"<p>ZodiacCore supports flexible layered architectures. The standard template uses a 3-tier architecture, but you can extend it to a 4-tier architecture when your application requires additional separation of concerns.</p>"},{"location":"user-guide/architecture/#standard-3-tier-architecture","title":"Standard 3-Tier Architecture","text":"<p>The recommended structure consists of three layers:</p>"},{"location":"user-guide/architecture/#1-api-presentation-layer","title":"1. API (Presentation Layer)","text":"<p>Location: <code>app/api/</code></p> <p>Responsibilities:</p> <ul> <li>Handle HTTP requests and responses</li> <li>Validate input data (Pydantic schemas)</li> <li>Transform domain models to response schemas</li> <li>Route requests to appropriate services</li> </ul> <p>What it contains:</p> <ul> <li>Routers (<code>app/api/routers/</code>): FastAPI route handlers</li> <li>Schemas (<code>app/api/schemas/</code>): Request/response Pydantic models</li> </ul> <p>Example: <pre><code>from typing import Annotated\nfrom dependency_injector.wiring import Provide, inject\nfrom fastapi import Depends\nfrom zodiac_core.pagination import PagedResponse, PageParams\nfrom zodiac_core.routing import APIRouter\n\nfrom app.api.schemas.item_schema import ItemSchema\nfrom app.application.services.item_service import ItemService\nfrom app.core.container import Container\n\nrouter = APIRouter()\n\n@router.get(\"\", response_model=PagedResponse[ItemSchema])\n@inject\nasync def list_items(\n    page_params: Annotated[PageParams, Depends()],\n    service: Annotated[ItemService, Depends(Provide[Container.item_service])],\n):\n    \"\"\"List items with pagination.\"\"\"\n    return await service.list_items(page_params)\n</code></pre></p> <p>Key Points:</p> <ul> <li>Routers are thin - they delegate to services</li> <li>Dependencies are injected via <code>dependency-injector</code></li> <li>Response models are defined here (API contract)</li> </ul>"},{"location":"user-guide/architecture/#2-application-business-logic-layer","title":"2. Application (Business Logic Layer)","text":"<p>Location: <code>app/application/</code></p> <p>Responsibilities:</p> <ul> <li>Implement business logic and use cases</li> <li>Orchestrate operations across multiple repositories</li> <li>Validate business rules</li> <li>Handle domain-level exceptions</li> </ul> <p>What it contains:</p> <ul> <li>Services (<code>app/application/services/</code>): Business logic classes</li> </ul> <p>Example: <pre><code>from loguru import logger\nfrom zodiac_core.exceptions import NotFoundException\nfrom zodiac_core.pagination import PagedResponse, PageParams\n\nfrom app.infrastructure.database.models.item_model import ItemModel\nfrom app.infrastructure.database.repositories.item_repository import ItemRepository\n\nclass ItemService:\n    def __init__(self, item_repo: ItemRepository) -&gt; None:\n        self.item_repo = item_repo\n\n    async def get_by_id(self, item_id: int) -&gt; ItemModel:\n        \"\"\"Get an item by ID, raising NotFoundException if not found.\"\"\"\n        item = await self.item_repo.get_by_id(item_id)\n        if not item:\n            raise NotFoundException(message=f\"Item id '{item_id}' not found\")\n        return item\n\n    async def list_items(self, page_params: PageParams) -&gt; PagedResponse[ItemModel]:\n        \"\"\"List items with pagination.\"\"\"\n        result = await self.item_repo.list_items(page_params)\n        logger.bind(\n            page=page_params.page,\n            size=page_params.size,\n            total=result.total\n        ).debug(\"list_items\")\n        return result\n</code></pre></p> <p>Key Points:</p> <ul> <li>Services contain business logic, not data access</li> <li>Services depend on repositories (infrastructure), not the other way around</li> <li>Business exceptions are raised here</li> </ul>"},{"location":"user-guide/architecture/#3-infrastructure-implementation-layer","title":"3. Infrastructure (Implementation Layer)","text":"<p>Location: <code>app/infrastructure/</code></p> <p>Responsibilities:</p> <ul> <li>Implement data persistence (database, external APIs)</li> <li>Provide concrete implementations of abstractions</li> <li>Handle technical concerns (SQL queries, HTTP clients)</li> </ul> <p>What it contains:</p> <ul> <li>Database (<code>app/infrastructure/database/</code>):</li> <li>Models (<code>models/</code>): SQLModel table definitions</li> <li>Repositories (<code>repositories/</code>): Data access classes</li> <li>External (<code>app/infrastructure/external/</code>): Third-party API clients</li> </ul> <p>Example - Repository: <pre><code>from sqlalchemy import select\nfrom zodiac_core.db.repository import BaseSQLRepository\nfrom zodiac_core.pagination import PagedResponse, PageParams\n\nfrom app.infrastructure.database.models.item_model import ItemModel\n\nclass ItemRepository(BaseSQLRepository):\n    async def get_by_id(self, item_id: int) -&gt; ItemModel | None:\n        \"\"\"Get an item by ID.\"\"\"\n        async with self.session() as session:\n            stmt = select(ItemModel).where(ItemModel.id == item_id)\n            result = await session.execute(stmt)\n            return result.scalar_one_or_none()\n\n    async def list_items(self, params: PageParams) -&gt; PagedResponse[ItemModel]:\n        \"\"\"List items with pagination using BaseSQLRepository.paginate_query.\"\"\"\n        stmt = select(ItemModel).order_by(ItemModel.id)\n        return await self.paginate_query(stmt, params)\n</code></pre></p> <p>Example - External Client: <pre><code>from loguru import logger\nfrom zodiac_core.http import ZodiacClient\n\nclass GitHubClient:\n    def __init__(self, client: ZodiacClient) -&gt; None:\n        self.client = client\n\n    async def fetch_homepage(self) -&gt; str:\n        \"\"\"Fetch GitHub homepage HTML.\"\"\"\n        response = await self.client.get(\"https://github.com\")\n        logger.info(\"Fetched GitHub homepage\")\n        return response.text\n</code></pre></p> <p>Key Points:</p> <ul> <li>Repositories inherit from <code>BaseSQLRepository</code> for pagination and session management</li> <li>External clients use <code>ZodiacClient</code> for HTTP requests with trace ID injection</li> <li>Infrastructure is swappable - you can change databases or APIs without touching business logic</li> </ul>"},{"location":"user-guide/architecture/#extended-4-tier-architecture-future","title":"Extended 4-Tier Architecture (Future)","text":"<p>When your application grows in complexity, you may want to introduce a Domain Layer between the Application and Infrastructure layers. This creates a 4-tier architecture with stricter separation of concerns:</p>"},{"location":"user-guide/architecture/#api-layer-4-tier","title":"API Layer (4-Tier)","text":"<ul> <li>Same as in 3-tier architecture</li> <li>Handles HTTP requests and responses</li> <li>Validates input data</li> <li>Transforms domain entities to response schemas</li> </ul>"},{"location":"user-guide/architecture/#application-layer-4-tier","title":"Application Layer (4-Tier)","text":"<ul> <li>Location: <code>app/application/</code></li> <li>Responsibilities:<ul> <li>Orchestrates domain services and entities</li> <li>Coordinates workflows and use cases</li> <li>Handles application-level concerns (transactions, coordination)</li> <li>Transforms between domain entities and infrastructure models</li> </ul> </li> <li>What it contains:<ul> <li>Services (<code>app/application/services/</code>): Use case orchestration classes</li> <li>DTOs (<code>app/application/dtos/</code>): Data transfer objects for application boundaries</li> </ul> </li> <li>Key Difference: In 4-tier, Application layer focuses on orchestration rather than business logic</li> </ul>"},{"location":"user-guide/architecture/#domain-layer-future-addition","title":"Domain Layer - Future Addition","text":"<ul> <li>Location: <code>app/domain/</code></li> <li>Responsibilities:<ul> <li>Contains core business logic and domain models</li> <li>Defines domain entities and value objects</li> <li>Implements domain services</li> <li>Enforces business rules and invariants</li> <li>Defines repository interfaces (abstractions)</li> </ul> </li> <li>What it contains:<ul> <li>Entities (<code>app/domain/entities/</code>): Domain models with business logic</li> <li>Value Objects (<code>app/domain/value_objects/</code>): Immutable domain concepts</li> <li>Domain Services (<code>app/domain/services/</code>): Domain-specific operations</li> <li>Repository Interfaces (<code>app/domain/repositories/</code>): Abstract repository contracts</li> </ul> </li> </ul>"},{"location":"user-guide/architecture/#infrastructure-layer-4-tier","title":"Infrastructure Layer (4-Tier)","text":"<ul> <li>Same structure as in 3-tier architecture</li> <li>Key Difference: Implements domain repository interfaces defined in the Domain layer</li> <li>Provides concrete implementations of domain abstractions</li> </ul> <p>Note: The 4-tier architecture is not yet implemented in the standard template, but the structure is designed to accommodate this extension when needed. You can add the Domain layer as your application evolves.</p>"},{"location":"user-guide/architecture/#dependency-injection-container","title":"Dependency Injection Container","text":"<p>Location: <code>app/core/container.py</code></p> <p>The DI container wires all layers together, managing the lifecycle and dependencies of components.</p>"},{"location":"user-guide/architecture/#container-definition","title":"Container Definition","text":"<p>The container is typically defined in <code>app/core/container.py</code>: it declares providers (Factory/Singleton) for repositories, services, and other infrastructure. Only the API layer (routers) needs to request dependencies via <code>Depends(Provide[Container.xxx])</code>; the container injects service \u2192 repository and other lower-layer dependencies when it constructs those objects.</p> <pre><code>from dependency_injector import containers, providers\n\nclass Container(containers.DeclarativeContainer):\n    config = providers.Configuration()\n    item_repository = providers.Factory(ItemRepository)\n    item_service = providers.Factory(ItemService, item_repo=item_repository)\n    # ...\n</code></pre>"},{"location":"user-guide/architecture/#wiring","title":"Wiring","text":"<p>With dependency-injector, only the modules that use <code>Depends(Provide[Container.xxx])</code> must be \"wired\" to the container \u2014 i.e. the API router modules. You call <code>container.wire(modules=[...])</code> at startup with the list of those module names (e.g. <code>\"app.api.routers.item_router\"</code>). That way, when a route runs and asks for <code>Container.item_service</code>, the container can resolve it.</p> <p>Service and infrastructure layers do not need to be wired: they are created by the container via <code>providers.Factory(...)</code> and receive their dependencies in the constructor.</p>"},{"location":"user-guide/architecture/#benefits","title":"Benefits","text":"<ul> <li>Loose Coupling: Components don't create their dependencies</li> <li>Easy Testing: Mock dependencies in tests</li> <li>Configuration: Centralized dependency configuration</li> <li>Lifecycle Management: Singleton vs Factory patterns</li> </ul>"},{"location":"user-guide/architecture/#data-flow","title":"Data Flow","text":""},{"location":"user-guide/architecture/#3-tier-architecture-flow","title":"3-Tier Architecture Flow","text":"<p>Here's how a request flows through the 3-tier layers:</p> <pre><code>HTTP Request\n    \u2193\n[API Layer] Router receives request\n    \u2193 (injects service)\n[Application Layer] Service implements business logic\n    \u2193 (uses repository)\n[Infrastructure Layer] Repository queries database\n    \u2193 (returns data)\n[Application Layer] Service processes and returns\n    \u2193 (transforms to schema)\n[API Layer] Router returns response\n    \u2193\nHTTP Response\n</code></pre>"},{"location":"user-guide/architecture/#4-tier-architecture-flow-future","title":"4-Tier Architecture Flow (Future)","text":"<p>In a 4-tier architecture, the flow includes the Domain layer:</p> <pre><code>HTTP Request\n    \u2193\n[API Layer] Router receives request\n    \u2193 (injects application service)\n[Application Layer] Orchestrates use case\n    \u2193 (uses domain service/entity)\n[Domain Layer] Business logic and rules\n    \u2193 (uses repository interface)\n[Infrastructure Layer] Implements repository, queries database\n    \u2193 (returns domain entity)\n[Domain Layer] Processes domain logic\n    \u2193 (returns domain entity)\n[Application Layer] Transforms to DTO\n    \u2193 (transforms to schema)\n[API Layer] Router returns response\n    \u2193\nHTTP Response\n</code></pre>"},{"location":"user-guide/architecture/#example-flow-get-apiv1itemspage1size20-3-tier","title":"Example Flow: <code>GET /api/v1/items?page=1&amp;size=20</code> (3-Tier)","text":"<ol> <li>Router (<code>item_router.py</code>):</li> <li>Receives request with <code>PageParams</code></li> <li>Injects <code>ItemService</code> from container</li> <li> <p>Calls <code>service.list_items(page_params)</code></p> </li> <li> <p>Service (<code>item_service.py</code>):</p> </li> <li>Receives <code>PageParams</code></li> <li>Calls <code>item_repo.list_items(page_params)</code></li> <li>Logs the operation</li> <li> <p>Returns <code>PagedResponse[ItemModel]</code></p> </li> <li> <p>Repository (<code>item_repository.py</code>):</p> </li> <li>Builds SQL query: <code>select(ItemModel).order_by(ItemModel.id)</code></li> <li>Calls <code>paginate_query(stmt, params)</code></li> <li> <p>Returns <code>PagedResponse[ItemModel]</code></p> </li> <li> <p>Router (back):</p> </li> <li>Transforms <code>ItemModel</code> to <code>ItemSchema</code> (via response_model)</li> <li>Returns wrapped response</li> </ol>"},{"location":"user-guide/architecture/#configuration","title":"Configuration","text":"<p>Location: <code>config/</code></p> <p>Configuration is managed through <code>.ini</code> files:</p> <ul> <li><code>config/app.ini</code> - Base configuration (all environments)</li> <li><code>config/app.develop.ini</code> - Development overrides</li> <li><code>config/app.production.ini</code> - Production overrides</li> </ul> <p>The container loads configuration:</p> <pre><code>from pathlib import Path\nfrom zodiac_core.config import ConfigManagement\n\nconfig_dir = Path(__file__).resolve().parent.parent / \"config\"\nconfig_files = ConfigManagement.get_config_files(\n    search_paths=[config_dir],\n    env_var=\"ENV\",\n    default_env=\"develop\",\n)\ncontainer.config.from_ini(*config_files)\n</code></pre> <p>Access configuration in the container:</p> <pre><code># In main.py lifespan\ndb_url = container.config.db.url()\ndb_echo = container.config.db.echo.as_(bool)\n</code></pre>"},{"location":"user-guide/architecture/#best-practices","title":"Best Practices","text":""},{"location":"user-guide/architecture/#1-keep-layers-independent","title":"1. Keep Layers Independent","text":"<ul> <li>\u2705 API layer doesn't import from Infrastructure (in 3-tier)</li> <li>\u2705 Application layer doesn't know about FastAPI</li> <li>\u2705 Infrastructure layer doesn't contain business logic</li> <li>\u2705 Domain layer (4-tier) doesn't depend on Infrastructure or Application layers</li> </ul>"},{"location":"user-guide/architecture/#2-use-dependency-injection","title":"2. Use Dependency Injection","text":"<ul> <li>\u2705 Inject dependencies via constructor</li> <li>\u2705 Use the container to wire dependencies</li> <li>\u274c Don't create dependencies inside classes</li> </ul>"},{"location":"user-guide/architecture/#3-repository-pattern","title":"3. Repository Pattern","text":"<ul> <li>\u2705 Use <code>BaseSQLRepository</code> for database operations</li> <li>\u2705 Use <code>paginate_query()</code> for pagination</li> <li>\u2705 Keep repositories focused on data access</li> </ul>"},{"location":"user-guide/architecture/#4-service-layer","title":"4. Service Layer","text":"<ul> <li>\u2705 In 3-tier: Put business logic in application services</li> <li>\u2705 In 4-tier: Put business logic in domain services/entities; application services orchestrate</li> <li>\u2705 Services orchestrate repositories</li> <li>\u2705 Raise domain exceptions (e.g., <code>NotFoundException</code>)</li> </ul>"},{"location":"user-guide/architecture/#5-response-schemas","title":"5. Response Schemas","text":"<ul> <li>\u2705 Define schemas in API layer</li> <li>\u2705 Transform domain models to schemas</li> <li>\u2705 Use Pydantic for validation</li> </ul>"},{"location":"user-guide/architecture/#summary","title":"Summary","text":"<p>The layered architecture with DI provides:</p> <ul> <li>Clear separation between presentation, business logic, and data access</li> <li>Testability through dependency injection</li> <li>Maintainability through well-defined boundaries</li> <li>Scalability through swappable implementations</li> <li>Flexibility to adapt to your project's needs (3-tier or 4-tier)</li> </ul>"},{"location":"user-guide/architecture/#choosing-your-architecture","title":"Choosing Your Architecture","text":"<ul> <li>Start with 3-tier: The standard template uses a 3-tier architecture, which is sufficient for most applications</li> <li>Extend to 4-tier: When you need stricter domain modeling and want to separate domain logic from application orchestration, you can introduce a Domain layer</li> <li>Not mandatory: ZodiacCore doesn't enforce a specific number of layers - choose what fits your project best</li> </ul> <p>This architecture is the foundation of the <code>standard-3tier</code> template generated by <code>zodiac new</code>. Start with the template and extend it as your application grows.</p>"},{"location":"user-guide/cli/","title":"zodiac CLI","text":"<p>The zodiac command is the CLI for scaffolding Zodiac-based projects. Use the zodiac extra when you want the CLI; use zodiac-core alone when only the library is needed in a project.</p>"},{"location":"user-guide/cli/#install","title":"Install","text":"<p>To use the CLI:</p> <pre><code>uv add \"zodiac-core[zodiac]\"\n</code></pre>"},{"location":"user-guide/cli/#commands","title":"Commands","text":"<ul> <li><code>zodiac --help</code> \u2014 show top-level help and subcommands.</li> <li><code>zodiac new PROJECT_NAME --tpl TEMPLATE_ID -o OUTPUT_DIR</code> \u2014 generate a new project from a template.</li> </ul>"},{"location":"user-guide/cli/#options-zodiac-new","title":"Options (zodiac new)","text":"Argument / Option Required Description <code>PROJECT_NAME</code> Yes Name of the project. <code>--tpl</code> / <code>template</code> Yes Template id. Currently supported: <code>standard-3tier</code>. <code>-o</code> / <code>--output</code> Yes Directory where the project will be generated. <code>-f</code> / <code>--force</code> No Overwrite files in the target directory if it exists."},{"location":"user-guide/cli/#example","title":"Example","text":"<pre><code>zodiac new my_app --tpl standard-3tier -o ./projects\n</code></pre>"},{"location":"user-guide/cli/#generated-project-architecture","title":"Generated Project Architecture","text":"<p>The <code>standard-3tier</code> template generates a project following the Standard 3-Tier Layered Architecture with Dependency Injection:</p> <ul> <li>API (Presentation): FastAPI routers and request/response handling</li> <li>Application (Logic): Business logic and use case orchestration</li> <li>Infrastructure (Implementation): Database models, repositories, and external integrations</li> </ul> <p>The project uses <code>dependency-injector</code> for managing component dependencies, providing a clean separation of concerns and making the codebase more testable and maintainable.</p> <p>Note: While the template uses a 3-tier architecture, ZodiacCore supports flexible layered architectures. You can extend it to a 4-tier architecture with a Domain layer when needed. See the Architecture Guide for detailed information.</p>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":"<p>This guide will walk you through building a complete, production-ready FastAPI application using <code>ZodiacCore</code> in 5 minutes.</p>"},{"location":"user-guide/getting-started/#1-generate-your-project","title":"1. Generate Your Project","text":"<p>The easiest way to get started is using the zodiac CLI to scaffold a complete project structure:</p> <pre><code># Install the CLI\nuv add \"zodiac-core[zodiac]\"\n\n# Generate a new project\nzodiac new my_app --tpl standard-3tier -o ./projects\ncd projects/my_app\n</code></pre> <p>The <code>standard-3tier</code> template generates a project following the Standard 3-Tier Layered Architecture with Dependency Injection:</p> <ul> <li>API (Presentation): FastAPI routers and request/response handling</li> <li>Application (Logic): Business logic and use case orchestration</li> <li>Infrastructure (Implementation): Database models, repositories, and external integrations</li> </ul> <p>The project uses <code>dependency-injector</code> for managing component dependencies, providing clean separation of concerns and making the codebase more testable and maintainable.</p> <p>Note: While the template uses a 3-tier architecture, ZodiacCore supports flexible layered architectures. You can extend it to a 4-tier architecture with a Domain layer when needed. See the Architecture Guide for details.</p>"},{"location":"user-guide/getting-started/#2-project-structure","title":"2. Project Structure","text":"<p>After generation, your project will have this structure:</p> <pre><code>my_app/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 api/              # Presentation layer (routers, schemas)\n\u2502   \u2502   \u251c\u2500\u2500 routers/\n\u2502   \u2502   \u2514\u2500\u2500 schemas/\n\u2502   \u251c\u2500\u2500 application/      # Business logic layer (services)\n\u2502   \u2502   \u2514\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 infrastructure/   # Implementation layer (DB, external clients)\n\u2502   \u2502   \u251c\u2500\u2500 database/\n\u2502   \u2502   \u2514\u2500\u2500 external/\n\u2502   \u2514\u2500\u2500 core/             # DI container and configuration\n\u251c\u2500\u2500 config/               # Environment-based configuration files\n\u251c\u2500\u2500 tests/                # Test suite\n\u2514\u2500\u2500 main.py               # Application entry point\n</code></pre>"},{"location":"user-guide/getting-started/#3-understanding-the-architecture","title":"3. Understanding the Architecture","text":""},{"location":"user-guide/getting-started/#dependency-injection-container","title":"Dependency Injection Container","text":"<p>The project uses <code>dependency-injector</code> to manage dependencies. The container is defined in <code>app/core/container.py</code>.</p> <pre><code>from dependency_injector import containers, providers\n\nclass Container(containers.DeclarativeContainer):\n    config = providers.Configuration()\n\n    # Infrastructure layer\n    item_repository = providers.Factory(ItemRepository)\n\n    # Application layer\n    item_service = providers.Factory(\n        ItemService,\n        item_repo=item_repository,\n    )\n</code></pre> <p>Dependencies are injected into routers using FastAPI's <code>Depends</code>. In <code>main.py</code>, the generated project uses <code>Container.initialize([config_dir])</code>, which loads config from <code>.ini</code> and wires all router modules (files named <code>*_router.py</code>) under <code>app.api.routers</code>; when you add a new router file, it is picked up automatically.</p> <pre><code>from dependency_injector.wiring import Provide, inject\nfrom fastapi import Depends\n\n@router.get(\"\")\n@inject\nasync def list_items(\n    service: Annotated[ItemService, Depends(Provide[Container.item_service])],\n):\n    return await service.list_items(params)\n</code></pre>"},{"location":"user-guide/getting-started/#professional-pagination-with-paginate_query","title":"Professional Pagination with <code>paginate_query</code>","text":"<p>The generated project uses <code>BaseSQLRepository.paginate_query()</code> for pagination, which automatically handles:</p> <ul> <li>Session management</li> <li>Total count calculation</li> <li>Limit/offset application</li> <li>Response packaging</li> </ul> <p>Repository Example:</p> <pre><code>from sqlalchemy import select\nfrom zodiac_core.db.repository import BaseSQLRepository\nfrom zodiac_core.pagination import PagedResponse, PageParams\n\nclass ItemRepository(BaseSQLRepository):\n    async def list_items(self, params: PageParams) -&gt; PagedResponse[ItemModel]:\n        \"\"\"List items with pagination using BaseSQLRepository.paginate_query.\"\"\"\n        stmt = select(ItemModel).order_by(ItemModel.id)\n        return await self.paginate_query(stmt, params)\n</code></pre> <p>Service Example:</p> <pre><code>class ItemService:\n    def __init__(self, item_repo: ItemRepository) -&gt; None:\n        self.item_repo = item_repo\n\n    async def list_items(self, page_params: PageParams) -&gt; PagedResponse[ItemModel]:\n        \"\"\"List items with pagination.\"\"\"\n        return await self.item_repo.list_items(page_params)\n</code></pre> <p>Router Example:</p> <pre><code>@router.get(\"\", response_model=PagedResponse[ItemSchema])\n@inject\nasync def list_items(\n    page_params: Annotated[PageParams, Depends()],\n    service: Annotated[ItemService, Depends(Provide[Container.item_service])],\n):\n    \"\"\"List items with pagination.\"\"\"\n    return await service.list_items(page_params)\n</code></pre> <p>No manual <code>skip</code>/<code>limit</code> calculations needed! The <code>paginate_query</code> method handles everything automatically.</p>"},{"location":"user-guide/getting-started/#4-configuration","title":"4. Configuration","text":"<p>The project uses file-based configuration. Configuration files are in the <code>config/</code> directory:</p> <ul> <li><code>config/app.ini</code> - Base configuration</li> <li><code>config/app.develop.ini</code> - Development overrides</li> <li><code>config/app.production.ini</code> - Production overrides</li> </ul> <p>The configuration is loaded based on the <code>ENV</code> environment variable:</p> <pre><code>from pathlib import Path\nfrom zodiac_core.config import ConfigManagement\n\nconfig_dir = Path(__file__).resolve().parent.parent / \"config\"\nconfig_files = ConfigManagement.get_config_files(\n    search_paths=[config_dir],\n    env_var=\"ENV\",\n    default_env=\"develop\",\n)\ncontainer.config.from_ini(*config_files)\n</code></pre>"},{"location":"user-guide/getting-started/#5-standard-response-wrapper","title":"5. Standard Response Wrapper","text":"<p>When you use Zodiac's <code>APIRouter</code>, all successful responses are automatically wrapped in a standard structure:</p> <pre><code>@router.get(\"/items/{item_id}\")\nasync def get_item(item_id: int):\n    return {\"id\": 1, \"name\": \"Example\"}\n</code></pre> <p>The resulting JSON will be: <pre><code>{\n  \"code\": 0,\n  \"message\": \"Success\",\n  \"data\": {\n    \"id\": 1,\n    \"name\": \"Example\"\n  }\n}\n</code></pre></p>"},{"location":"user-guide/getting-started/#6-handling-exceptions","title":"6. Handling Exceptions","text":"<p>Raise <code>ZodiacException</code> subclasses for automatic error handling:</p> <pre><code>from zodiac_core.exceptions import NotFoundException, BadRequestException\n\n@router.get(\"/items/{item_id}\")\nasync def get_item(item_id: int):\n    if item_id == 0:\n        raise BadRequestException(message=\"Item ID cannot be zero\")\n\n    item = await service.get_by_id(item_id)\n    if not item:\n        raise NotFoundException(message=f\"Item {item_id} not found\")\n\n    return item\n</code></pre> <p>The response will automatically follow the standard error format: <pre><code>{\n  \"code\": 404,\n  \"message\": \"Item 101 not found\",\n  \"data\": null\n}\n</code></pre></p>"},{"location":"user-guide/getting-started/#7-running-your-application","title":"7. Running Your Application","text":"<p>Install dependencies and run:</p> <pre><code># Install dependencies\nuv sync\n\n# Run the application\nuv run uvicorn main:app --reload\n</code></pre> <p>Visit:</p> <ul> <li>API Documentation: http://127.0.0.1:8000/docs</li> <li>Health Check: http://127.0.0.1:8000/api/v1/health</li> </ul>"},{"location":"user-guide/getting-started/#summary","title":"Summary","text":"<p>You now have a fully functional application with:</p> <ul> <li>\u2705 3-Tier Layered Architecture with Dependency Injection</li> <li>\u2705 Professional Pagination using <code>paginate_query</code></li> <li>\u2705 Structured Logging with trace ID propagation</li> <li>\u2705 Standard Error Handling with automatic response wrapping</li> <li>\u2705 File-based Configuration for different environments</li> <li>\u2705 Async Database Sessions with SQLModel</li> </ul>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Architecture Guide \u2014 Layered design, DI container, and project structure</li> <li>API Reference \u2014 Config, database, pagination, routing, schemas, and more</li> <li>CLI Documentation \u2014 Scaffold new projects and modules with <code>zodiac new</code></li> </ul>"},{"location":"user-guide/installation/","title":"Installation Guide","text":"<p>ZodiacCore is designed to be modular. You can install only what you need.</p>"},{"location":"user-guide/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python: 3.12 or higher</li> <li>Package Manager: <code>pip</code> (standard) or <code>uv</code> (recommended for performance)</li> </ul>"},{"location":"user-guide/installation/#1-basic-installation","title":"1. Basic Installation","text":"<p>For a minimal setup (Core utilities, Logging, Exception Handling, Middleware, ...):</p> <pre><code>uv add zodiac-core\n</code></pre>"},{"location":"user-guide/installation/#2-installing-with-database-support","title":"2. Installing with Database Support","text":"<p>ZodiacCore separates database dependencies to keep the core lightweight. You can choose to install a single database backend or multiple backends simultaneously.</p>"},{"location":"user-guide/installation/#sql-support-sqlalchemy-sqlmodel","title":"SQL Support (SQLAlchemy + SQLModel)","text":"<p>To use SQL databases, you must install the <code>sql</code> extra along with the appropriate async database driver for your specific database.</p> <pre><code># 1. Install SQL support\nuv add \"zodiac-core[sql]\"\n\n# 2. Install preferred async driver (Examples)\nuv add asyncpg       # For PostgreSQL\nuv add aiosqlite     # For SQLite\nuv add aiomysql      # For MySQL\n</code></pre>"},{"location":"user-guide/installation/#mongodb-support-motor","title":"MongoDB Support (Motor)","text":"<p>Installs the <code>motor</code> extra so you can use the async MongoDB driver in your app. Built-in MongoDB session and repository helpers are planned for a future release. For now, this extra is for dependency convenience when you integrate Motor directly.</p> <pre><code>uv add \"zodiac-core[mongo]\"\n</code></pre>"},{"location":"user-guide/installation/#multiple-databases","title":"Multiple Databases","text":"<p>To install support for both SQL and MongoDB:</p> <pre><code>uv add \"zodiac-core[sql,mongo]\"\n</code></pre>"},{"location":"user-guide/installation/#cli-zodiac-command","title":"CLI (zodiac command)","text":"<p>To use the zodiac CLI for scaffolding projects:</p> <pre><code>uv add \"zodiac-core[zodiac]\"\n</code></pre> <p>Then run <code>zodiac --help</code>. See zodiac CLI for usage.</p>"},{"location":"user-guide/installation/#3-installing-everything-for-development","title":"3. Installing Everything (For Development)","text":"<p>If you are setting up a development environment or need all features:</p> <pre><code>uv sync --all-extras --all-groups\n</code></pre>"},{"location":"user-guide/installation/#4-local-development-editable-install","title":"4. Local development (editable install)","text":"<p>When developing the repo locally, install in editable mode so code changes take effect without reinstalling. To run the zodiac CLI while developing, include the zodiac extra:</p> <pre><code>uv pip install -e \".[zodiac]\"\n</code></pre> <p>Then <code>zodiac --help</code> and <code>zodiac new ...</code> use the local code. To add dev/test/docs deps:</p> <pre><code>uv sync --all-extras --all-groups\n</code></pre>"},{"location":"user-guide/installation/#5-verifying-installation","title":"5. Verifying Installation","text":"<p>You can verify the installed version and importability:</p> <pre><code>python -c \"import zodiac_core; print(zodiac_core.__version__)\"\n</code></pre> <p>To verify the CLI (after installing with the zodiac extra):</p> <pre><code>zodiac --help\n</code></pre>"}]}